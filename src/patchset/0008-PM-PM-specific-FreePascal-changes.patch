From 527b3408094c263fe54a5141661e74067f396fbf Mon Sep 17 00:00:00 2001
From: Paulo Meira <10246101+PMeira@users.noreply.github.com>
Date: Fri, 16 Feb 2018 16:48:50 -0200
Subject: [PATCH] PM: PM-specific FreePascal changes

---
 Parallel_Version/Source/Common/DSSGlobals.pas      |  18 +-
 Parallel_Version/Source/Common/ExportResults.pas   |   4 +-
 Parallel_Version/Source/Common/Solution.pas        | 125 ++++++++--
 Parallel_Version/Source/Executive/ExecCommands.pas |  17 +-
 Parallel_Version/Source/Executive/ExecOptions.pas  |   2 +-
 .../Source/Parallel_Lib/Parallel_Lib.pas           | 252 ++++++++++++++-------
 Parallel_Version/Source/Parallel_Lib/cpucount.pas  |  76 +++++++
 7 files changed, 378 insertions(+), 116 deletions(-)
 create mode 100644 Parallel_Version/Source/Parallel_Lib/cpucount.pas

diff --git a/Parallel_Version/Source/Common/DSSGlobals.pas b/Parallel_Version/Source/Common/DSSGlobals.pas
index ea5bfde..4879da9 100644
--- a/Parallel_Version/Source/Common/DSSGlobals.pas
+++ b/Parallel_Version/Source/Common/DSSGlobals.pas
@@ -245,7 +245,7 @@ VAR
    ActorCPU           : Array of integer;
    ActorStatus        : Array of integer;
    ActorProgressCount : Array of integer;
-   ActorProgress      : Array of TProgress;
+   {$IFNDEF FPC}ActorProgress      : Array of TProgress;{$ENDIF}
    ActorPctProgress   : Array of integer;
    ActorHandle        : Array of TThread;
    Parallel_enabled   : Boolean;
@@ -375,6 +375,7 @@ Begin
   SHGetFolderPath (0, CSIDL_LOCAL_APPDATA, 0, 0, ThePath);
   Result := ThePath;
 End;
+{$ENDIF}
 
 function GetOutputDirectory:String;
 begin
@@ -654,14 +655,11 @@ FUNCTION GetDSSVersion: String;
 {$ELSE}
 FUNCTION GetDSSVersion: String;
 var
-
   InfoSize, Wnd: DWORD;
   VerBuf: Pointer;
   FI: PVSFixedFileInfo;
   VerSize: DWORD;
   MajorVer, MinorVer, BuildNo, RelNo :DWORD;
-
-
 Begin
     Result := 'Unknown.' ;
 
@@ -682,8 +680,8 @@ Begin
         FreeMem(VerBuf);
       end;
     end;
-
 End;
+{$ENDIF}
 
 
 PROCEDURE WriteDLLDebugFile(Const S:String);
@@ -865,11 +863,13 @@ end;
 initialization
 
 //***************Initialization for Parallel Processing*************************
-
+{$IFNDEF LINUX}
    CPU_Cores        :=  CPUCount;
-
+{$ELSE}
+   CPU_Cores        :=  GetLogicalCpuCount; // FreePascal's CPUCount returns 1 on Linux
+{$ENDIF}
    setlength(ActiveCircuit,CPU_Cores + 1);
-   setlength(ActorProgress,CPU_Cores + 1);
+   {$IFNDEF FPC}setlength(ActorProgress,CPU_Cores + 1);{$ENDIF}
    setlength(ActorCPU,CPU_Cores + 1);
    setlength(ActorStatus,CPU_Cores + 1);
    setlength(ActorProgressCount,CPU_Cores + 1);
@@ -914,7 +914,7 @@ initialization
    for ActiveActor := 1 to CPU_Cores do
    begin
     ActiveCircuit[ActiveActor]        :=  nil;
-    ActorProgress[ActiveActor]        :=  nil;
+    {$IFNDEF FPC}ActorProgress[ActiveActor]        :=  nil;{$ENDIF}
     ActiveDSSClass[ActiveActor]       :=  nil;
     ActorStatus[ActiveActor]          :=  1;
     EventStrings[ActiveActor]         := TStringList.Create;
diff --git a/Parallel_Version/Source/Common/ExportResults.pas b/Parallel_Version/Source/Common/ExportResults.pas
index 60a98c7..717caac 100644
--- a/Parallel_Version/Source/Common/ExportResults.pas
+++ b/Parallel_Version/Source/Common/ExportResults.pas
@@ -66,7 +66,7 @@ Procedure ExportBusLevels(FileNm:String);
 
 IMPLEMENTATION
 
-Uses uComplex,  Arraydef, System.sysutils,   Circuit, DSSClassDefs, DSSGlobals,
+Uses uComplex,  Arraydef, sysutils,   Circuit, DSSClassDefs, DSSGlobals,
      uCMatrix,  solution, CktElement, Utilities, Bus, MathUtil, DSSClass,
      PDElement, PCElement, Generator,  Sensor, Load, RegControl, Transformer,
      ParserDel, Math, Ymatrix, LineGeometry, WireData, LineCode, XfmrCode, NamedObject,
@@ -85,7 +85,7 @@ Begin
   Nterm := pElem.Nterms;
   k:=0;
   BusName := (StripExtension(pElem.FirstBus));
-  Write(F, System.Sysutils.Format('%s.%s',[pElem.DSSClassName, pElem.Name]));
+  Write(F, Format('%s.%s',[pElem.DSSClassName, pElem.Name]));
 
 
   Write(F, Format(',%d',[NTerm]));
diff --git a/Parallel_Version/Source/Common/Solution.pas b/Parallel_Version/Source/Common/Solution.pas
index bc7de0f..caff37f 100644
--- a/Parallel_Version/Source/Common/Solution.pas
+++ b/Parallel_Version/Source/Common/Solution.pas
@@ -47,13 +47,20 @@ USES
     Dynamics,
     EnergyMeter,
     SysUtils,
+    Parallel_Lib,
+    CktElement,
+{$IFDEF WINDOWS}
+    Windows,
+{$ELSE}    
+    BaseUnix, Unix,
+{$ENDIF}
+{$IFDEF FPC}Classes, Strings{$ELSE}
     System.Diagnostics,
     System.TimeSpan,
     System.Classes,
-    System.SyncObjs,
-    Parallel_Lib,
-    Windows,
-    CktElement;
+    System.SyncObjs
+{$ENDIF}    
+    ;
 
 CONST
 
@@ -284,13 +291,16 @@ VAR
 implementation
 
 USES  SolutionAlgs,
-      DSSClassDefs, DSSGlobals, DSSForms, PDElement,  ControlElem, Fault,
+      DSSClassDefs, DSSGlobals, {$IFDEF FPC} CmdForms,{$ELSE} DSSForms, {$ENDIF} PDElement,  ControlElem, Fault,
       Executive, AutoAdd,  YMatrix, Load,CKtTree,
-      ParserDel, Generator,Capacitor,SHELLAPI,
+      ParserDel, Generator,Capacitor,
+{$IFDEF WINDOWS}
+      SHELLAPI,
+{$ENDIF}      
 {$IFDEF DLL_ENGINE}
       ImplGlobals,  // to fire events
 {$ENDIF}
-      Math,  Circuit, Utilities, KLUSolve, ScriptEdit, PointerList, Line,
+      Math,  Circuit, Utilities, KLUSolve, {$IFNDEF FPC}ScriptEdit,{$ENDIF} PointerList, Line,
       Transformer, Reactor
 ;
 
@@ -488,9 +498,10 @@ End;
 
 // ===========================================================================================
 PROCEDURE TSolutionObj.Solve(ActorID : Integer);
+{$IFNDEF FPC}
 var
-  ScriptEd  : TScriptEdit;
-
+ScriptEd  : TScriptEdit;
+{$ENDIF}
 Begin
      ActiveCircuit[ActorID].Issolved := False;
      SolutionWasAttempted[ActorID]   := TRUE;
@@ -529,7 +540,7 @@ Try
 {$ENDIF}
 
     {CheckFaultStatus;  ???? needed here??}
-     QueryPerformanceCounter(GStartTime);
+     {$IFNDEF FPC}QueryPerformanceCounter(GStartTime);{$ENDIF}
 {
      Case Dynavars.SolutionMode OF
          SNAPSHOT:     SolveSnap;
@@ -559,7 +570,7 @@ Try
       ActorHandle[ActorID].Terminate;
       ActorHandle[ActorID].Free;
     end;
-    ActorHandle[ActorID] :=  TSolver.Create(false,ActorCPU[ActorID],ActorID,ScriptEd.UpdateSummaryForm);
+    ActorHandle[ActorID] :=  TSolver.Create(false,ActorCPU[ActorID],ActorID,{$IFNDEF FPC}ScriptEd.UpdateSummaryForm{$ELSE}nil{$ENDIF});
     if not Parallel_enabled then
       ActorHandle[ActorID].WaitFor; // If the parallel features are not active it will work as the classic version
 Except
@@ -592,9 +603,11 @@ Begin
         Else If Vmag <> 0.0         Then ErrorSaved^[i] := Abs(1.0 - VmagSaved^[i]/Vmag);
 
         VMagSaved^[i] := Vmag;  // for next go-'round
-
+{$IFNDEF FPC}
         MaxError := Max(MaxError, ErrorSaved^[i]);  // update max error
-
+{$ELSE}
+       if ErrorSaved^[i] > MaxError Then MaxError := ErrorSaved^[i]; // TODO - line above used to compile in FPC
+{$ENDIF}
     End;
 
 
@@ -1043,7 +1056,7 @@ VAR
 Begin
    SnapShotInit(ActorID);
    TotalIterations    := 0;
-   QueryPerformanceCounter(SolveStartTime);
+   {$IFNDEF FPC}QueryPerformanceCounter(SolveStartTime);{$ENDIF}
    REPEAT
 
        Inc(ControlIteration);
@@ -1072,7 +1085,7 @@ Begin
 {$IFDEF DLL_ENGINE}
    Fire_StepControls;
 {$ENDIF}
-   QueryPerformanceCounter(SolveEndtime);
+{$IFNDEF FPC}QueryPerformanceCounter(SolveEndTime);{$ENDIF}
    Solve_Time_Elapsed := ((SolveEndtime-SolveStartTime)/CPU_Freq)*1000000;
    Iteration := TotalIterations;  { so that it reports a more interesting number }
 
@@ -1085,7 +1098,7 @@ Begin
    Result := 0;
 
    LoadsNeedUpdating := TRUE;  // Force possible update of loads and generators
-   QueryPerformanceCounter(SolveStartTime);
+   {$IFNDEF FPC}QueryPerformanceCounter(SolveStartTime);{$ENDIF}
 
    If SystemYChanged THEN
    begin
@@ -1107,7 +1120,7 @@ Begin
        ConvergedFlag := TRUE;
    End;
 
-   QueryPerformanceCounter(SolveEndtime);
+   {$IFNDEF FPC}QueryPerformanceCounter(SolveEndTime);{$ENDIF}
    Solve_Time_Elapsed  := ((SolveEndtime-SolveStartTime)/CPU_Freq)*1000000;
    Total_Time_Elapsed  :=  Total_Time_Elapsed + Solve_Time_Elapsed;
    Iteration := 1;
@@ -1594,6 +1607,7 @@ End;
 {*******************************************************************************
 *           Routine created to empty a recently created folder                 *
 ********************************************************************************}
+{$IFDEF WINDOWS}
 procedure DelFilesFromDir(Directory, FileMask: string; DelSubDirs: Boolean);
 var
   SourceLst: string;
@@ -1601,7 +1615,7 @@ var
 begin
   FillChar(FOS, SizeOf(FOS), 0);
   FOS.wFunc := FO_DELETE;
-  SourceLst := Directory + '\' + FileMask + #0;
+  SourceLst := Directory + PathDelim + FileMask + #0;
   FOS.pFrom := PChar(SourceLst);
   if not DelSubDirs then
     FOS.fFlags := FOS.fFlags OR FOF_FILESONLY;
@@ -1611,6 +1625,66 @@ begin
   FOS.fFlags := FOS.fFlags OR FOF_SILENT;
   SHFileOperation(FOS);
 end;
+{$ENDIF}
+{$IFDEF UNIX}
+procedure DeltreeDir(Directory: string);
+var 
+  Info: TSearchRec;
+Begin
+  If FindFirst(Directory + PathDelim + '*', faAnyFile and faDirectory, Info) = 0 then
+  begin
+    Repeat
+      With Info do
+      begin
+        If (name = '.') or (name = '..') then continue;
+        If (Attr and faDirectory) = faDirectory then
+        begin
+          DeltreeDir(Directory + PathDelim + Name)
+        end
+        else
+        begin
+          DeleteFile(Directory + PathDelim + Name);
+        end;
+      end;
+    Until FindNext(info) <> 0;
+  end;    
+  rmdir(Directory);
+end;
+
+procedure DelFilesFromDir(Directory, FileMask: string; DelSubDirs: Boolean);
+var 
+  Info: TSearchRec;
+  flags: LongInt;
+Begin
+  if DelSubDirs then
+    flags := faAnyFile and faDirectory
+  else
+    flags := faAnyFile;
+  
+  If FindFirst(Directory + PathDelim + FileMask, flags, Info) = 0 then
+  begin
+    Repeat
+      With Info do
+      begin
+        if (name = '.') or (name = '..') then continue;
+        If (Attr and faDirectory) = faDirectory then
+        begin
+          try
+            DeltreeDir(Directory + PathDelim + Name)
+          except
+            Writeln('Could not remove directory ' + Directory + PathDelim + Name);
+          end;
+        end
+        else
+        begin
+          DeleteFile(Directory + PathDelim + Name);
+        end;
+      end;
+    Until FindNext(info) <> 0;
+  end;
+end;
+{$ENDIF}
+
 {*******************************************************************************
 *   This routine evaluates if the current location is the best or if its       *
 *   Necessary to move back one PDE just to cover a wider area                  *
@@ -1679,7 +1753,7 @@ Begin
   i         :=  i - 1;
   while flag do
   begin
-    if Fileroot[i] = '\' then flag  :=  False;
+    if Fileroot[i] = PathDelim then flag  :=  False;
     i         :=  i - 1;
     if i  < 0 then flag :=  False;
   end;
@@ -2390,7 +2464,7 @@ begin
 // Update Loop time is called from end of time step cleanup
 // Timer is based on beginning of SolveSnap time
 
-   QueryPerformanceCounter(LoopEndtime);
+   {$IFNDEF FPC}QueryPerformanceCounter(LoopEndTime);{$ENDIF}
    Step_Time_Elapsed  := ((LoopEndtime-SolveStartTime)/CPU_Freq)*1000000;
 
 end;
@@ -2453,9 +2527,16 @@ begin
   FInfoProc       :=  CallBack;
   FreeOnTerminate := False;
   ActorID         :=  ID;
+{$IFNDEF UNIX}  
   Parallel.Set_Process_Priority(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
   Parallel.Set_Thread_Priority(handle,THREAD_PRIORITY_TIME_CRITICAL);
   Parallel.Set_Thread_affinity(handle,local_CPU);
+{$ELSE}
+  Parallel.Set_Process_Priority(FpGetpid(), REALTIME_PRIORITY_CLASS);
+  Parallel.Set_Thread_Priority(self,THREAD_PRIORITY_TIME_CRITICAL);
+  Parallel.Set_Thread_affinity(handle,local_CPU);
+{$ENDIF}  
+
 end;
 
 {*******************************************************************************
@@ -2465,7 +2546,7 @@ end;
 
 procedure TSolver.Execute;
 var
-  ScriptEd  : TScriptEdit;
+  {$IFNDEF FPC}ScriptEd  : TScriptEdit;{$ENDIF}
   idx       : Integer;
   begin
     with ActiveCircuit[ActorID].Solution do
@@ -2499,7 +2580,9 @@ var
                DosimpleMsg('Unknown solution mode.', 481);
            End;
 
+{$IFNDEF FPC}           
         QueryPerformanceCounter(GEndTime);
+{$ENDIF}
         Total_Solve_Time_Elapsed := ((GEndTime-GStartTime)/CPU_Freq)*1000000;
         Total_Time_Elapsed := Total_Time_Elapsed + Total_Solve_Time_Elapsed;
         ActorStatus[ActorID]  :=  1;
diff --git a/Parallel_Version/Source/Executive/ExecCommands.pas b/Parallel_Version/Source/Executive/ExecCommands.pas
index 89277a1..1a5789d 100644
--- a/Parallel_Version/Source/Executive/ExecCommands.pas
+++ b/Parallel_Version/Source/Executive/ExecCommands.pas
@@ -27,10 +27,11 @@ PROCEDURE ProcessCommand(Const CmdLine:String);
 
 implementation
 
-Uses DSSGlobals, ExecHelper, Executive, ExecOptions, ShowOptions,
-     ExportOptions, ParserDel, LoadShape, {$IFNDEF FPC} DSSForms,
-     PlotOptions, ConnectOptions, {$ENDIF} sysutils, Utilities, SolutionAlgs,
-     DSSClassDefs, windows, KLUSolve;
+Uses DSSGlobals, ExecHelper, Executive, ExecOptions, ShowOptions, 
+     ExportOptions, ParserDel, LoadShape, 
+     {$IFDEF FPC} CmdForms,{$ELSE} Windows, PlotOptions, DSSForms, ConnectOptions,{$ENDIF}
+     sysutils, Utilities, SolutionAlgs,
+     DSSClassDefs, KLUSolve;
 
 
 PROCEDURE DefineCommands;
@@ -606,7 +607,11 @@ Begin
               ActiveCircuit[ActiveActor].Solution.Calc_Inc_Matrix(ActiveActor);
             end;
        110: begin
+              {$IFNDEF FPC}
               ShowDiakopticsBox;
+              {$ELSE}
+              DSSInfoMessageDlg ('Not supported in FPC version');CmdResult := 0;
+              {$ENDIF}
             end;
        111: begin
               ActiveCircuit[ActiveActor].Solution.Calc_Inc_Matrix_Org(ActiveActor);
@@ -663,7 +668,11 @@ Begin
         9: CmdResult := DoSetCmd(1);  // changed from DoSolveCmd; //'solve';
        10: CmdResult := DoEnableCmd;
        11: CmdResult := DoDisableCmd;
+       {$IFNDEF FPC}
        12: CmdResult := DoPlotCmd; //'plot';
+       {$ELSE}
+       12: begin DSSInfoMessageDlg ('Plotting not supported in FPC version');CmdResult := 0; end;
+       {$ENDIF}
        13: CmdResult := DoResetCmd(ActiveActor); //'resetmonitors';
        15: CmdResult := DoSetCmd(0);  //'set WITH no solve'
        16: CmdResult := DoPropertyDump;
diff --git a/Parallel_Version/Source/Executive/ExecOptions.pas b/Parallel_Version/Source/Executive/ExecOptions.pas
index 10abcfd..d4da4ce 100644
--- a/Parallel_Version/Source/Executive/ExecOptions.pas
+++ b/Parallel_Version/Source/Executive/ExecOptions.pas
@@ -27,7 +27,7 @@ FUNCTION DoGetCmd_NoCircuit:Boolean;  // Get Commands that do not require a circ
 implementation
 
 Uses DSSClassDefs, DSSGlobals, ParserDel, Math,     Executive,  ExecHelper,
-     LoadShape,    Utilities,  Sysutils, ScriptEdit,  Solution, Energymeter;
+     LoadShape,    Utilities,  Sysutils, {$IFNDEF FPC}ScriptEdit,{$ENDIF} Solution, Energymeter;
 
 
 PROCEDURE DefineOptions;
diff --git a/Parallel_Version/Source/Parallel_Lib/Parallel_Lib.pas b/Parallel_Version/Source/Parallel_Lib/Parallel_Lib.pas
index 42b9a3c..5e228f1 100644
--- a/Parallel_Version/Source/Parallel_Lib/Parallel_Lib.pas
+++ b/Parallel_Version/Source/Parallel_Lib/Parallel_Lib.pas
@@ -1,79 +1,173 @@
-unit Parallel_Lib;
-
-{**********************Parallel Library for OpenDSS*****************************
-* This library gives acces to the processor to handle the affinity of the
-* Specified process and thread to a specific processor core
-* This library gives access to the Windows API for such purpose
-* Written by Davis Montenegro 06-17-2016
-*
-* Used for multi-core processing in OpenDSS
-********************************************************************************
-}
-
-
-interface
-
-uses
-  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes
-  , math, vcl.Dialogs;
-
-type
-  TParallel_Lib = class(TObject)
-  public
-    function Set_Thread_Affinity(Hnd : THandle; CPU : integer): Integer;
-    function Set_Process_Priority(Hnd: THandle; P_priority : integer): Integer;
-    function Set_Thread_Priority(Hnd: THandle; T_priority : integer): Integer;
-    function Get_Thread_Priority(Hnd: THandle): String;
-    function Get_Number_of_CPUs(): Integer;
-  end;
-
-implementation
-    function TParallel_Lib.Set_Thread_Affinity(Hnd : THandle; CPU : integer): Integer;
-    var
-      CPU_bit   : integer;
-      Op_Result : Dword;
-    begin
-       CPU_bit    :=  floor(power(2, CPU));
-       Op_Result  := SetThreadAffinityMask(Hnd,CPU_bit);
-       if Op_Result = 0 then raise Exception.Create('Error setting thread affinity mask : ' + IntToStr(GetLastError));
-       Result   :=  Op_Result;
-    end;
-    function TParallel_Lib.Set_Process_Priority(Hnd: THandle; P_priority : integer):Integer;
-    var
-      Op_result   :  bool;
-    begin
-      Result      :=  0;
-      Op_Result   :=  SetPriorityClass(Hnd, P_priority);
-      if Op_result=false then ShowMessage('Impossible to set the Process Priority');
-      if Op_result then Result  :=1;
-    end;
-    function TParallel_Lib.Set_Thread_Priority(Hnd: THandle; T_priority : integer):Integer;
-    var
-      Op_result   :  bool;
-    begin
-      Result      :=  0;
-      Op_Result   :=  SetThreadPriority(Hnd,T_priority);
-      if Op_Result = false then ShowMessage('Impossible to set the Thread Priority');
-      if Op_result then Result  :=1;
-    end;
-    function TParallel_Lib.Get_Thread_Priority(Hnd: THandle): String;
-    var
-      Num_priority  : integer;
-    begin
-      Num_Priority  :=  GetThreadPriority(Hnd);
-      case Num_Priority of
-        0:  Result    :=  'Normal';
-        1:  Result    :=  'Above Normal';
-        2:  Result    :=  'Highest';
-        15: Result    :=  'Time Critical';
-        -1: Result    :=  'Below Normal';
-        -2: Result    :=  'Lowest';
-      else
-          Result    :=  'Not known';
-      end;
-    end;
-    function TParallel_Lib.Get_Number_of_CPUs(): Integer;
-    begin
-      Result  :=  CPUCount;
-    end;
-end.
+unit Parallel_Lib;
+
+{**********************Parallel Library for OpenDSS*****************************
+* This library gives acces to the processor to handle the affinity of the
+* Specified process and thread to a specific processor core
+* This library gives access to the Windows API for such purpose
+* Written by Davis Montenegro 06-17-2016
+*
+* Used for multi-core processing in OpenDSS
+********************************************************************************
+}
+
+
+interface
+
+uses
+{$IFNDEF FPC}
+  Winapi.Windows, Winapi.Messages, vcl.Dialogs,
+{$ELSE}
+    {$IFDEF WINDOWS}
+    windows,
+    {$ELSE}
+    initc, cpucount, BaseUnix, Unix,
+    {$ENDIF}
+{$ENDIF}  
+  SysUtils, Variants, Classes, math;
+
+const REALTIME_PRIORITY_CLASS = 16;
+  
+{$IFDEF WINDOWS}
+const THREAD_PRIORITY_TIME_CRITICAL = 15;
+type
+  TParallel_Lib = class(TObject)
+  public
+    function Set_Thread_Affinity(Hnd : THandle; CPU : integer): Integer;
+    function Set_Process_Priority(Hnd: THandle; P_priority : integer): Integer;
+    function Set_Thread_Priority(Hnd: THandle; T_priority : integer): Integer;
+    function Get_Thread_Priority(Hnd: THandle): String;
+    function Get_Number_of_CPUs(): Integer;
+  end;
+{$ELSE}
+const THREAD_PRIORITY_TIME_CRITICAL = tpTimeCritical;
+type
+  TParallel_Lib = class(TObject)
+  public
+    function Set_Thread_Affinity(Hnd : THandle; CPU : integer): Integer;
+    function Set_Process_Priority(Hnd: TPid; P_priority : integer): Integer;
+    function Set_Thread_Priority(thread: TThread; T_priority : TThreadPriority): Integer;
+    function Get_Thread_Priority(Hnd: THandle): String;
+    function Get_Number_of_CPUs(): Integer;
+  end;
+    
+{$ENDIF}
+
+implementation
+{$IFNDEF UNIX}
+    function TParallel_Lib.Set_Thread_Affinity(Hnd : THandle; CPU : integer): Integer;
+    var
+      CPU_bit   : integer;
+      Op_Result : Dword;
+    begin
+       CPU_bit    :=  floor(power(2, CPU));
+       Op_Result  := SetThreadAffinityMask(Hnd,CPU_bit);
+       if Op_Result = 0 then raise Exception.Create('Error setting thread affinity mask : ' + IntToStr(GetLastError));
+       Result   :=  Op_Result;
+    end;
+    function TParallel_Lib.Set_Process_Priority(Hnd: THandle; P_priority : integer):Integer;
+    var
+      Op_result   :  bool;
+    begin
+      Result      :=  0;
+      Op_Result   :=  SetPriorityClass(Hnd, P_priority);
+      if Op_result=false then 
+        {$IFNDEF FPC}ShowMessage{$ELSE}WriteLn{$ENDIF}('Impossible to set the Process Priority');
+      if Op_result then Result  :=1;
+    end;
+    function TParallel_Lib.Set_Thread_Priority(Hnd: THandle; T_priority : integer):Integer;
+    var
+      Op_result   :  bool;
+    begin
+      Result      :=  0;
+      Op_Result   :=  SetThreadPriority(Hnd,T_priority);
+      if Op_Result = false then 
+        {$IFNDEF FPC}ShowMessage{$ELSE}WriteLn{$ENDIF}('Impossible to set the Thread Priority');
+      if Op_result then Result  :=1;
+    end;
+    function TParallel_Lib.Get_Thread_Priority(Hnd: THandle): String;
+    var
+      Num_priority  : integer;
+    begin
+      Num_Priority  :=  GetThreadPriority(Hnd);
+      case Num_Priority of
+        0:  Result    :=  'Normal';
+        1:  Result    :=  'Above Normal';
+        2:  Result    :=  'Highest';
+        15: Result    :=  'Time Critical';
+        -1: Result    :=  'Below Normal';
+        -2: Result    :=  'Lowest';
+      else
+          Result    :=  'Not known';
+      end;
+    end;
+    function TParallel_Lib.Get_Number_of_CPUs(): Integer;
+    begin
+      Result  :=  CPUCount;
+    end;
+{$ELSE}    
+    //function pthread_setaffinity_np(pid : Ptruint; cpusetsize : QWord; cpuset : pointer) : longint; cdecl; external;
+    
+    function TParallel_Lib.Set_Thread_Affinity(Hnd : THandle; CPU : integer): Integer;
+    // The following commented code segfaults but it's based on 
+    // http://free-pascal-general.1045716.n5.nabble.com/GetAffinity-SetAffinity-tp3351231p5717539.html
+    // An alternative may be to include a separate C file to handle this using the correct macros
+    {const
+      cpu_SetSize = 8; // 64 cores max
+    var
+      cpu_set : QWord;  //cpu_set_type sufficient for 64-core CPU
+      Op_Result : longint;
+    begin
+      cpu_set := 1 shl CPU;
+      Op_Result := pthread_setaffinity_np(Hnd,cpu_SetSize,@cpu_set);
+      if Op_Result = 0 then raise Exception.Create('Error setting thread affinity mask');
+      Result   :=  Op_Result;
+    end;}
+    begin
+      Result := 0;
+    end;
+    
+    function TParallel_Lib.Set_Thread_Priority(thread: TThread; T_priority : TThreadPriority): Integer;
+    begin
+      Result      :=  0;
+      try
+        thread.Priority := T_priority;
+        if thread.Priority = T_priority then
+            Result  := 1;
+      except
+        WriteLn('Impossible to set the Thread Priority');
+      end;
+    end;
+    
+    function TParallel_Lib.Set_Process_Priority(Hnd: TPid; P_priority : integer):Integer;
+    var
+      Op_result   :  Integer;
+    begin
+      Result      :=  0;
+      Op_Result   :=  fpsetpriority (prio_process,Hnd,P_priority);
+      if Op_result = -1 then 
+        WriteLn('Impossible to set the Process Priority');
+      if Op_result <> 0 then Result  :=1;
+    end;
+    
+    function TParallel_Lib.Get_Thread_Priority(Hnd: THandle): String;
+    var
+      Num_priority  : integer;
+    begin
+      Num_Priority  :=  ThreadGetPriority(Hnd);
+      case Num_Priority of
+        0:  Result    :=  'Normal';
+        1:  Result    :=  'Above Normal';
+        2:  Result    :=  'Highest';
+        15: Result    :=  'Time Critical';
+        -1: Result    :=  'Below Normal';
+        -2: Result    :=  'Lowest';
+      else
+          Result    :=  'Not known';
+      end;
+    end;
+    function TParallel_Lib.Get_Number_of_CPUs(): Integer;
+    begin
+      Result  :=  GetLogicalCpuCount();
+    end;
+{$ENDIF}
+end.
diff --git a/Parallel_Version/Source/Parallel_Lib/cpucount.pas b/Parallel_Version/Source/Parallel_Lib/cpucount.pas
new file mode 100644
index 0000000..24b5dbf
--- /dev/null
+++ b/Parallel_Version/Source/Parallel_Lib/cpucount.pas
@@ -0,0 +1,76 @@
+// Unit originally from FPC Wiki: http://wiki.freepascal.org/Example_of_multi-threaded_application:_array_of_threads
+
+unit cpucount;
+interface
+//returns number of cores: a computer with two hyperthreaded cores will report 4
+function GetLogicalCpuCount: Integer;
+ 
+implementation
+ 
+{$IF defined(windows)}
+uses windows;
+{$endif}
+ 
+{$IF defined(darwin)}
+uses ctypes, sysctl;
+{$endif} 
+ 
+{$IFDEF Linux}
+uses initc, ctypes;
+ 
+const _SC_NPROCESSORS_ONLN = 83;
+function sysconf(i: cint): clong; cdecl; external name 'sysconf';
+{$ENDIF}
+ 
+ 
+function GetLogicalCpuCount: integer;
+// returns a good default for the number of threads on this system
+{$IF defined(windows)}
+//returns total number of processors available to system including logical hyperthreaded processors
+var
+  i: Integer;
+  ProcessAffinityMask, SystemAffinityMask: DWORD_PTR;
+  Mask: DWORD;
+  SystemInfo: SYSTEM_INFO;
+begin
+  if GetProcessAffinityMask(GetCurrentProcess, ProcessAffinityMask, SystemAffinityMask)
+  then begin
+    Result := 0;
+    for i := 0 to 31 do begin
+      Mask := DWord(1) shl i;
+      if (ProcessAffinityMask and Mask)<>0 then
+        inc(Result);
+    end;
+  end else begin
+    //can't get the affinity mask so we just report the total number of processors
+    GetSystemInfo(SystemInfo);
+    Result := SystemInfo.dwNumberOfProcessors;
+  end;
+end;
+{$ELSEIF defined(UNTESTEDsolaris)}
+  begin
+    t = sysconf(_SC_NPROC_ONLN);
+  end;
+{$ELSEIF defined(freebsd) or defined(darwin)}
+var
+  mib: array[0..1] of cint;
+  len: cint;
+  t: cint;
+begin
+  mib[0] := CTL_HW;
+  mib[1] := HW_NCPU;
+  len := sizeof(t);
+  fpsysctl(pchar(@mib), 2, @t, @len, Nil, 0);
+  Result:=t;
+end;
+{$ELSEIF defined(linux)}
+  begin
+    Result:=sysconf(_SC_NPROCESSORS_ONLN);
+  end;
+ 
+{$ELSE}
+  begin
+    Result:=1;
+  end;
+{$ENDIF}
+end.
\ No newline at end of file
-- 
2.10.0.windows.1

