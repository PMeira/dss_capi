From e956db0fc89354a5369f8f3c196a5f59d9a793f8 Mon Sep 17 00:00:00 2001
From: Paulo Meira <10246101+PMeira@users.noreply.github.com>
Date: Fri, 16 Feb 2018 16:56:13 -0200
Subject: [PATCH] Classic-to-PM: port many bug fixes and new features from the Classic
 version

---
 Parallel_Version/Source/Common/DSSClass.pas        |   1 +
 Parallel_Version/Source/Common/ExportResults.pas   |  90 ++++++++++-------
 Parallel_Version/Source/Common/Solution.pas        |  27 +++--
 Parallel_Version/Source/Common/SolutionAlgs.pas    |  41 ++++----
 Parallel_Version/Source/Controls/ExpControl.pas    |  43 ++++----
 Parallel_Version/Source/Controls/InvControl.pas    |   6 +-
 Parallel_Version/Source/Controls/RegControl.pas    |   2 +-
 Parallel_Version/Source/DLL/ImplCapControls.pas    |  14 ++-
 Parallel_Version/Source/DLL/ImplCircuit.pas        |   3 +-
 Parallel_Version/Source/DLL/ImplReclosers.pas      |   4 +-
 Parallel_Version/Source/DLL/ImplRegControls.pas    |  12 +++
 Parallel_Version/Source/DLL/ImplSolution.pas       |  15 ++-
 Parallel_Version/Source/DLL/OpenDSSengine.ridl     |  22 ++++-
 Parallel_Version/Source/Executive/ExecOptions.pas  | 109 ++++++++++++---------
 .../Source/Executive/ExportOptions.pas             |   7 +-
 Parallel_Version/Source/General/LoadShape.pas      |   8 +-
 Parallel_Version/Source/Meters/Monitor.pas         |   4 +-
 Parallel_Version/Source/PCElements/PVsystem.pas    |   4 +-
 Parallel_Version/Source/PCElements/Storage.pas     |   3 +-
 Parallel_Version/Source/PCElements/vccs.pas        |  45 +++++----
 Parallel_Version/Source/PDElements/Line.pas        |  52 ++++++----
 Parallel_Version/Source/PDElements/Transformer.pas |  37 ++++++-
 22 files changed, 350 insertions(+), 199 deletions(-)

diff --git a/Parallel_Version/Source/Common/DSSClass.pas b/Parallel_Version/Source/Common/DSSClass.pas
index 0977605..2503eb2 100644
--- a/Parallel_Version/Source/Common/DSSClass.pas
+++ b/Parallel_Version/Source/Common/DSSClass.pas
@@ -260,6 +260,7 @@ END;
 
 Function TDSSClass.GetActiveObj:Pointer; // Get address of active obj of this class
 BEGIN
+    ActiveElement := ElementList.ActiveIndex ;
     If ActiveElement>0 THEN
        Result := ElementList.Get(ActiveElement)
     Else
diff --git a/Parallel_Version/Source/Common/ExportResults.pas b/Parallel_Version/Source/Common/ExportResults.pas
index 717caac..e543983 100644
--- a/Parallel_Version/Source/Common/ExportResults.pas
+++ b/Parallel_Version/Source/Common/ExportResults.pas
@@ -33,7 +33,7 @@ Procedure ExportCapacity(FileNm:String);
 Procedure ExportOverloads(FileNm:String);
 Procedure ExportUnserved(FileNm:String; UE_Only:Boolean);
 Procedure ExportYprim(FileNm:String);
-Procedure ExportY(FileNm:String);
+Procedure ExportY(FileNm:String; TripletOpt:Boolean);
 Procedure ExportSeqZ(FileNm:String);
 Procedure ExportBusCoords(FileNm:String);
 Procedure ExportLosses(FileNm:String);
@@ -1498,7 +1498,7 @@ Begin
    { Solve for Fault Injection Currents}
 
              YFault := TcMatrix.CreateMatrix(NumNodesThisBus);
-             Getmem(VFault, Sizeof( VFault^[1])* NumNodesThisBus);
+             Getmem(VFault, Sizeof(Complex)* NumNodesThisBus);
 
              {Build YscTemp}
 
@@ -2583,13 +2583,14 @@ Begin
 End;
 
 // illustrate retrieval of System Y using compressed column format
-Procedure ExportY(FileNm:String);
+Procedure ExportY(FileNm:String; TripletOpt:Boolean);
 
 {Exports System Y Matrix in Node Order}
 
 Var
     F                :TextFile;
     i,j,p            :LongWord;
+    col,row          :LongWord;
     hY               :NativeUInt;
     nBus, nNZ        :LongWord;
     ColPtr, RowIdx   :array of LongWord;
@@ -2613,41 +2614,58 @@ Begin
      Assignfile(F,FileNm);
      ReWrite(F);
 
-     SetLength (ColPtr, nBus + 1);
-     SetLength (RowIdx, nNZ);
-     SetLength (cVals, nNZ);
-     GetCompressedMatrix(hY, nBus + 1, nNZ, @ColPtr[0], @RowIdx[0], @cVals[0]);
-
-     {Write out fully qualified Bus Names}
-      With ActiveCircuit[ActiveActor] Do Begin
-
-        Writeln(F, Format('%d, ',[NumNodes]));
-(*        For i := 1 to NumNodes DO BEGIN
-           j :=  MapNodeToBus^[i].BusRef;
-           Write(F, Format('%s.%-d, +j,',[BusList.Get(j), MapNodeToBus^[i].NodeNum]));
-        END;
-        Writeln(F);
-*)
-        For i := 1 to NumNodes Do Begin
-           j :=  MapNodeToBus^[i].BusRef;
-           Write(F, Format('"%s.%-d", ',[Uppercase(BusList.Get(j)), MapNodeToBus^[i].NodeNum]));
-           For j := 1 to NumNodes Do Begin
-              re := 0.0;
-              im := 0.0;
-              // search for a non-zero element [i,j]
-              //  DSS indices are 1-based, KLU indices are 0-based
-              for p := ColPtr[j-1] to ColPtr[j] - 1 do begin
-                if RowIdx[p] + 1 = i then begin
-                  re := cVals[p].re;
-                  im := cVals[p].im;
+     if TripletOpt then begin
+       SetLength (ColPtr, nNZ);
+       SetLength (RowIdx, nNZ);
+       SetLength (cVals, nNZ);
+       GetTripletMatrix (hY, nNZ, @RowIdx[0], @ColPtr[0], @cVals[0]);
+       Writeln(F, 'Row,Col,G,B');
+       for i := 0 to nNZ - 1 do begin
+         col := ColPtr[i] + 1;
+         row := RowIdx[i] + 1;
+         if row >= col then begin
+           re := cVals[i].re;
+           im := cVals[i].im;
+           Writeln (F, Format('%d,%d,%.10g,%.10g', [row, col, re, im]));
+         end;
+       end;
+     end else begin
+       SetLength (ColPtr, nBus + 1);
+       SetLength (RowIdx, nNZ);
+       SetLength (cVals, nNZ);
+       GetCompressedMatrix (hY, nBus + 1, nNZ, @ColPtr[0], @RowIdx[0], @cVals[0]);
+
+       {Write out fully qualified Bus Names}
+        With ActiveCircuit[ActiveActor] Do Begin
+
+          Writeln(F, Format('%d, ',[NumNodes]));
+  (*        For i := 1 to NumNodes DO BEGIN
+             j :=  MapNodeToBus^[i].BusRef;
+             Write(F, Format('%s.%-d, +j,',[BusList.Get(j), MapNodeToBus^[i].NodeNum]));
+          END;
+          Writeln(F);
+  *)
+          For i := 1 to NumNodes Do Begin
+             j :=  MapNodeToBus^[i].BusRef;
+             Write(F, Format('"%s.%-d", ',[Uppercase(BusList.Get(j)), MapNodeToBus^[i].NodeNum]));
+             For j := 1 to NumNodes Do Begin
+                re := 0.0;
+                im := 0.0;
+                // search for a non-zero element [i,j]
+                //  DSS indices are 1-based, KLU indices are 0-based
+                for p := ColPtr[j-1] to ColPtr[j] - 1 do begin
+                  if RowIdx[p] + 1 = i then begin
+                    re := cVals[p].re;
+                    im := cVals[p].im;
+                  end;
                 end;
-              end;
-              Write(F, Format('%-13.10g, +j %-13.10g,', [re, im]));
-           End;
-           Writeln(F);
-        End;
+                Write(F, Format('%-13.10g, +j %-13.10g,', [re, im]));
+             End;
+             Writeln(F);
+          End;
 
-      End;
+        End;
+     end;    
 
 
      GlobalResult := FileNm;
diff --git a/Parallel_Version/Source/Common/Solution.pas b/Parallel_Version/Source/Common/Solution.pas
index caff37f..674168f 100644
--- a/Parallel_Version/Source/Common/Solution.pas
+++ b/Parallel_Version/Source/Common/Solution.pas
@@ -34,6 +34,8 @@ unit Solution;
          0-th element is alway ground(complex zero volts).
  8-14-06 Revised power flow initialization; removed forward/backward sweep
 
+ 9-14-16 Added SampleTheMeters Flag to allow sampling energy meters in Time and DutyCycle mode
+
 }
 
 interface
@@ -166,12 +168,14 @@ TYPE
        LoadsNeedUpdating :Boolean;
        MaxControlIterations :Integer;
        MaxError :Double;
-       MaxIterations :Integer;
+       MaxIterations,
+       MinIterations :Integer;
        MostIterationsDone :Integer;
        NodeVbase :pDoubleArray;
        NumberOfTimes :Integer;  // Number of times to solve
        PreserveNodeVoltages:Boolean;
        RandomType :Integer;     //0 = none; 1 = gaussian; 2 = UNIFORM
+       SampleTheMeters : Boolean;  // Flag to allow sampling of EnergyMeters
        SeriesYInvalid :Boolean;
        SolutionCount :Integer;  // Counter incremented for each solution
        SolutionInitialized :Boolean;
@@ -395,10 +399,13 @@ Begin
     VoltageBaseChanged := TRUE;  // Forces Building of convergence check arrays
 
     MaxIterations    := 15;
+    MinIterations    := 2;
     MaxControlIterations  := 10;
     ConvergenceTolerance := 0.0001;
     ConvergedFlag := FALSE;
 
+    SampleTheMeters := FALSE;  // Flag to tell solution algorithm to sample the Energymeters
+
     IsDynamicModel   := FALSE;
     IsHarmonicModel  := FALSE;
 
@@ -820,7 +827,7 @@ Begin
        SolveSystem(NodeV, ActorID);
        LoadsNeedUpdating := FALSE;
 
-   Until (Converged(ActorID) and (Iteration > 1)) or (Iteration >= MaxIterations);
+   Until (Converged(ActorID) and (Iteration >= MinIterations)) or (Iteration >= MaxIterations);
 
 End;
 
@@ -887,7 +894,7 @@ Begin
                 im := im - dV^[i].im;
            End;
 
-       UNTIL (Converged(ActorID) and (Iteration > 1)) or (Iteration >= MaxIterations);
+       UNTIL (Converged(ActorID) and (Iteration >= MinIterations)) or (Iteration >= MaxIterations);
     End;
 End;
 
@@ -1857,7 +1864,8 @@ Begin
      Writeln(F, 'Set circuit=',  ActiveCircuit[ActiveActor].Name);
      Writeln(F, 'Set editor=',   DefaultEditor);
      Writeln(F, 'Set tolerance=', Format('%-g', [ConvergenceTolerance]));
-     Writeln(F, 'Set maxiter=',   MaxIterations:0);
+     Writeln(F, 'Set maxiterations=',   MaxIterations:0);
+     Writeln(F, 'Set miniterations=',   MinIterations:0);                                                         
      Writeln(F, 'Set loadmodel=', GetLoadModel);
 
      Writeln(F, 'Set loadmult=',    Format('%-g', [ActiveCircuit[ActiveActor].LoadMultiplier]));
@@ -2114,6 +2122,7 @@ begin
 
    SolutionInitialized := FALSE;   // reinitialize solution when mode set (except dynamics)
    PreserveNodeVoltages := FALSE;  // don't do this unless we have to
+   SampleTheMeters := FALSE;                         
 
    // Reset defaults for solution modes
    Case Dynavars.SolutionMode of
@@ -2122,6 +2131,7 @@ begin
        DAILYMODE:     Begin
                            DynaVars.h    := 3600.0;
                            NumberOfTimes := 24;
+                           SampleTheMeters := TRUE;
                       End;
        SNAPSHOT:      Begin
                            IntervalHrs   := 1.0;
@@ -2131,6 +2141,7 @@ begin
                            IntervalHrs   := 1.0;
                            DynaVars.h    := 3600.0;
                            NumberOfTimes := 8760;
+                           SampleTheMeters := TRUE;
                       End;
        DUTYCYCLE:     Begin
                            DynaVars.h  := 1.0;
@@ -2147,9 +2158,9 @@ begin
                            DynaVars.h    := 3600.0;
                            NumberOfTimes := 1;  // just one time step per Solve call expected
                       End;
-       MONTECARLO1:   Begin IntervalHrs    := 1.0;  End;
-       MONTECARLO2:   Begin DynaVars.h     := 3600.0;   End;
-       MONTECARLO3:   Begin IntervalHrs    := 1.0;   End;
+       MONTECARLO1:   Begin IntervalHrs    := 1.0;  SampleTheMeters := TRUE; End;
+       MONTECARLO2:   Begin DynaVars.h     := 3600.0;  SampleTheMeters := TRUE; End;
+       MONTECARLO3:   Begin IntervalHrs    := 1.0; SampleTheMeters := TRUE;  End;
        MONTEFAULT:    Begin IsDynamicModel := TRUE;  END;
        FAULTSTUDY:    Begin
                             IsDynamicModel := TRUE;
@@ -2157,10 +2168,12 @@ begin
        LOADDURATION1: Begin
                            DynaVars.h := 3600.0;
                            ActiveCircuit[ActiveActor].TrapezoidalIntegration := TRUE;
+                           SampleTheMeters := TRUE;
                       End;
        LOADDURATION2: Begin
                            DynaVars.intHour := 1;
                            ActiveCircuit[ActiveActor].TrapezoidalIntegration := TRUE;
+                           SampleTheMeters := TRUE;
                       End;
        AUTOADDFLAG :  Begin
                            IntervalHrs := 1.0;
diff --git a/Parallel_Version/Source/Common/SolutionAlgs.pas b/Parallel_Version/Source/Common/SolutionAlgs.pas
index 09f8f77..024d1b8 100644
--- a/Parallel_Version/Source/Common/SolutionAlgs.pas
+++ b/Parallel_Version/Source/Common/SolutionAlgs.pas
@@ -59,8 +59,12 @@ PROCEDURE FinishTimeStep(ActorID: integer);
 }
 Begin
     MonitorClass[ActorID].SampleAll(ActorID);
-    EndOfTimeStepCleanup(ActorID);
-    ActiveCircuit[ActorID].Solution.Increment_time;
+    With ActiveCircuit[ActorID].Solution Do Begin
+        If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID);   // Save Demand interval Files
+
+        EndOfTimeStepCleanup(ActorID);
+        Increment_time;
+    End;
 End;
 
 
@@ -120,14 +124,14 @@ Begin
           IF PriceCurveObj <> NIL THEN PriceSignal := PriceCurveObj.GetPrice(dblHour);
           SolveSnap(ActorID);
           MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
-          EnergyMeterClass[ActorID].SampleAll(ActorID); // Make all Energy Meters take a sample
+          If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID); // Make all Energy Meters take a sample
           EndOfTimeStepCleanup(ActorID);
           ActorPctProgress[ActorID]  :=  (N*100) div NumberofTimes;
 //          If (N mod Twopct)=0 Then ShowPctProgress((N*100) div NumberofTimes,ActorID);
       End;
   Finally
     MonitorClass[ActorID].SaveAll(ActorID);
-    EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files    See DIFilesAreOpen Logic
+    // EnergyMeterClass[ActorID].CloseAllDIFiles;   // Save Demand interval Files    See DIFilesAreOpen Logic
   End;
  End;
 End;
@@ -165,7 +169,7 @@ Begin
             IF PriceCurveObj<> NIL THEN PriceSignal := PriceCurveObj.GetPrice(dblHour);
             SolveSnap(ActorID);
             MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
-            EnergyMeterClass[ActorID].SampleAll(ActorID); // Make all Energy Meters take a sample
+            If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID); // Make all Energy Meters take a sample
 
             EndOfTimeStepCleanup(ActorID);
 
@@ -173,7 +177,7 @@ Begin
 
     Finally
       MonitorClass[ActorID].SaveAll(ActorID);
-      EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
+      If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
     End; {Try}
    End;  {WITH}
 End;
@@ -214,14 +218,14 @@ Begin
             IF PriceCurveObj<> NIL THEN PriceSignal := PriceCurveObj.GetPrice(dblHour);
             SolveSnap(ActorID);
             MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
-            EnergyMeterClass[ActorID].SampleAll(ActorID); // Make all Energy Meters take a sample
+            If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID); // Make all Energy Meters take a sample
 
             EndOfTimeStepCleanup(ActorID);
 
         End;
       Finally
         MonitorClass[ActorID].SaveAll(ActorID);
-        EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
+        If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
       End;
      End;  {WITH}
 End;
@@ -261,6 +265,7 @@ Begin
             // Assume pricesignal stays constant for dutycycle calcs
             SolveSnap(ActorID);
             MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
+            If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID);                                                                                               
             EndOfTimeStepCleanup(ActorID);
 
             ActorPctProgress[ActorID] :=  (N*100) div NumberofTimes;
@@ -268,6 +273,7 @@ Begin
         End;
       Finally
         MonitorClass[ActorID].SaveAll(ActorID);
+        If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
 //        ProgressHide(ActorID);
       End;
     End;
@@ -388,7 +394,7 @@ Begin
             Inc(DynaVars.intHour);
             SolveSnap(ActorID);
             MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
-            EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
+            If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
             ActorPctProgress[ActorID] :=  (N*100) div NumberofTimes;
 //            Show10PctProgress(N, NumberOfTimes, ActorID);
         End
@@ -400,6 +406,7 @@ Begin
         End;
      Finally
         MonitorClass[ActorID].SaveAll(ActorID);
+        If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);
 //        ProgressHide(ActorID);
      End;
    End;
@@ -450,7 +457,7 @@ Begin
             SolveSnap(ActorID);
 
             MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
-            EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
+            If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
 
             EndOfTimeStepCleanup(ActorID);
 
@@ -468,7 +475,7 @@ Begin
         End;
       Finally
         MonitorClass[ActorID].SaveAll(ActorID);
-        EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
+        If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
 //        ProgressHide(ActorID);
       End;
     End;
@@ -516,7 +523,7 @@ Begin
             SolveSnap(ActorID);
 
             MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
-            EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
+            If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
 
             ActorPctProgress[ActorID] :=  (N*100) div NumberofTimes;
 //            Show10PctProgress(N, NumberOfTimes, ActorID);
@@ -530,7 +537,7 @@ Begin
         End;
       Finally
         MonitorClass[ActorID].SaveAll(ActorID);
-        EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
+        If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
 //        ProgressHide(ActorID);
       End;
     End; {WITH}
@@ -592,7 +599,7 @@ Begin
               SolveSnap(ActorID);
 
               MonitorClass[ActorID].SampleAll(ActorID);     // Make all monitors take a sample
-              EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
+              If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
 
               EndOfTimeStepCleanup(ActorID);
 
@@ -613,7 +620,7 @@ Begin
       End;
     Finally
       MonitorClass[ActorID].SaveAll(ActorID);
-      EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
+      If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
 //      ProgressHide(ActorID);
     End;
  End; {WITH ActiveCircuit[ActiveActor]}
@@ -671,14 +678,14 @@ Begin
         SolveSnap(ActorID);
 
         MonitorClass[ActorID].SampleAll(ActorID);  // Make all monitors take a sample
-        EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
+        If SampleTheMeters then EnergyMeterClass[ActorID].SampleAll(ActorID);  // Make all meters take a sample
 
         EndOfTimeStepCleanup(ActorID);
 
       End;
     Finally
       MonitorClass[ActorID].SaveAll(ActorID);
-      EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
+      If SampleTheMeters then EnergyMeterClass[ActorID].CloseAllDIFiles(ActorID);   // Save Demand interval Files
     End;
   End; {WITH ActiveCircuit[ActiveActor]}
 
diff --git a/Parallel_Version/Source/Controls/ExpControl.pas b/Parallel_Version/Source/Controls/ExpControl.pas
index 686d7a1..36aed38 100644
--- a/Parallel_Version/Source/Controls/ExpControl.pas
+++ b/Parallel_Version/Source/Controls/ExpControl.pas
@@ -84,7 +84,7 @@ INTERFACE
             // Sample control quantities and set action times in Control Queue
             PROCEDURE   Sample(ActorID : Integer);  Override;
 
-            // ActiveCircuit[ActiveActor] the action that is pending from last sample
+            // Do the action that is pending from last sample
             PROCEDURE   DoPendingAction(Const Code, ProxyHdl:Integer;ActorID : Integer); Override;
 
             PROCEDURE   Reset; Override;  // Reset to initial defined state
@@ -311,7 +311,7 @@ Begin
 
      {
        Control elements are zero current sources that attach to a terminal of a
-       power-carrying device, but ActiveCircuit[ActiveActor] not alter voltage or current flow.
+       power-carrying device, but do not alter voltage or current flow.
        Define a default number of phases and conductors here and update in
        RecalcElementData routine if necessary. This allocates arrays for voltages
        and currents and gives more direct access to the values, if needed
@@ -342,7 +342,7 @@ Begin
      FPVSystemPointerList := PointerList.TPointerList.Create(20);  // Default size and increment
 
      // user parameters for dynamic Vreg
-     FVregInit := 1.0;
+     FVregInit := 1.0; // 0 means to find it during initialization
      FSlope := 50.0;
      FVregTau := 1200.0;
      FVregs := nil;
@@ -477,6 +477,7 @@ BEGIN
       PVSys.Varmode := VARMODEKVAR;  // Set var mode to VARMODEKVAR to indicate we might change kvar
       FTargetQ[i] := 0.0;
       Qbase  := PVSys.kVARating;
+      Qinvmaxpu := PVSys.kvarLimit / Qbase;                                     
       Qpu := PVSys.Presentkvar / Qbase; // no change for now
 
       if (FWithinTol[i]=False) then begin
@@ -534,30 +535,31 @@ begin
       Vpresent := 0;
       For j := 1 to PVSys.NPhases do Vpresent := Vpresent + Cabs(cBuffer[j]);
       FPresentVpu[i] := (Vpresent / PVSys.NPhases) / (basekV * 1000.0);
+      // if initializing with Vreg=0 in static mode, we want to FIND Vreg
+      if (ActiveCircuit[ActorID].Solution.ControlMode = CTRLSTATIC) and (FVregInit <= 0.0) then
+        FVregs[i] := FPresentVpu[i];
       // both errors are in per-unit
       Verr := Abs(FPresentVpu[i] - FPriorVpu[i]);
       Qerr := Abs(PVSys.Presentkvar - FTargetQ[i]) / PVSys.kVARating;
-
       // process the sample
       if (PVSys.InverterON = FALSE) and (PVSys.VarFollowInverter = TRUE) then begin // not injecting
-        if (FVregTau > 0.0) then FVregs[i] := FPresentVpu[i]; // tracking grid voltage while not injecting
+        if (FVregTau > 0.0) and (FVregs[i] <= 0.0) then
+          FVregs[i] := FPresentVpu[i]; // wake up to the grid voltage, otherwise track it while not injecting
         continue;
       end;
       PVSys.VWmode := FALSE;
-      if (FWithinTol[i] = False) then begin
-        if ((Verr > FVoltageChangeTolerance) or (Qerr > FVarChangeTolerance) or
-          (ActiveCircuit[ActorID].Solution.ControlIteration = 1)) then begin
-          FWithinTol[i] := False;
-          Set_PendingChange(CHANGEVARLEVEL,i);
-          With  ActiveCircuit[ActorID].Solution.DynaVars do
-            ControlActionHandle := ActiveCircuit[ActorID].ControlQueue.Push (intHour, t + TimeDelay, PendingChange[i], 0, Self, ActorID);
-          If ShowEventLog Then AppendtoEventLog('ExpControl.' + Self.Name+' '+PVSys.Name, Format
-            (' outside Hit Tolerance, Verr= %.5g, Qerr=%.5g', [Verr,Qerr]),ActorID);
-        end else begin
-          if ((Verr <= FVoltageChangeTolerance) and (Qerr <= FVarChangeTolerance)) then FWithinTol[i] := True;
-          If ShowEventLog Then AppendtoEventLog('ExpControl.' + Self.Name+' '+PVSys.Name, Format
-            (' within Hit Tolerance, Verr= %.5g, Qerr=%.5g', [Verr,Qerr]),ActorID);
-        end;
+      if ((Verr > FVoltageChangeTolerance) or (Qerr > FVarChangeTolerance) or
+        (ActiveCircuit[ActorID].Solution.ControlIteration = 1)) then begin
+        FWithinTol[i] := False;
+        Set_PendingChange(CHANGEVARLEVEL,i);
+        With  ActiveCircuit[ActorID].Solution.DynaVars do
+          ControlActionHandle := ActiveCircuit[ActorID].ControlQueue.Push (intHour, t + TimeDelay, PendingChange[i], 0, Self, ActorID);
+        If ShowEventLog Then AppendtoEventLog('ExpControl.' + Self.Name+' '+PVSys.Name, Format
+          (' outside Hit Tolerance, Verr= %.5g, Qerr=%.5g', [Verr,Qerr]),ActorID);
+      end else begin
+        FWithinTol[i] := True;
+        If ShowEventLog Then AppendtoEventLog('ExpControl.' + Self.Name+' '+PVSys.Name, Format
+          (' within Hit Tolerance, Verr= %.5g, Qerr=%.5g', [Verr,Qerr]),ActorID);
       end;
     end;  {For}
   end; {If FlistSize}
@@ -624,7 +626,7 @@ begin
   //Initialize arrays
   For i := 1 to FlistSize do begin
 //    PVSys := PVSysClass.Find(FPVSystemNameList.Strings[i-1]);
-//    Set_NTerms(PVSys.NTerms); // TOActiveCircuit[ActiveActor] - what is this for?
+//    Set_NTerms(PVSys.NTerms); // TODO - what is this for?
     FPriorVpu[i] := 0.0;
     FPresentVpu[i] := 0.0;
     FPriorQ[i] := -1.0;
@@ -697,7 +699,6 @@ Var
 begin
   for j := 1 to FPVSystemPointerList.ListSize do begin
     PVSys := ControlledElement[j];
-    FWithinTol[j] := False;
     if FVregTau > 0.0 then begin
       dt :=  ActiveCircuit[ActorID].Solution.Dynavars.h;
       Verr := FPresentVpu[j] - FVregs[j];
diff --git a/Parallel_Version/Source/Controls/InvControl.pas b/Parallel_Version/Source/Controls/InvControl.pas
index c85a042..e1093fd 100644
--- a/Parallel_Version/Source/Controls/InvControl.pas
+++ b/Parallel_Version/Source/Controls/InvControl.pas
@@ -1296,7 +1296,7 @@ BEGIN
                   Qnew[k] := sign(QNew[k])*0.99*PVSys.kvarLimit;
                   FHitkvarLimit[k] := True;
                 end;
-
+              QTemp2 := Qnew[k];
               //Convert output from CalcVoltWatt_pu to kW
               PVSys.VWmode  := TRUE;
               PVSys.VWYAxis := FVoltwattYAxis;
@@ -1360,7 +1360,6 @@ BEGIN
                         end;
                 end;
 
-              PTemp := PVSys.PresentkW;
               // if the desired kW and desired kvar exceed the kva rating of the PVSystem's inverter then...
               PVSys.SetNominalPVSystemOuput(ActorID);
               PTemp := PVSys.PresentkW;
@@ -1447,7 +1446,7 @@ BEGIN
                       PNew[k] :=FFinalpuPmpp[k];
 
                       If ShowEventLog Then AppendtoEventLog('InvControl.' + Self.Name+','+PVSys.Name+',',
-                       Format('**VV_VW mode set PVSystem output level to**, puPmpp= %.5g, PriorWatts= %.5g', [PVSys.puPmpp,FPriorWattspu[k]]),ActorID);
+                       Format('**VV_VW mode set PVSystem output level to**, puPmpp= %.5g, PriorWatts= %.5g', [PVSys.puPmpp,POld[k]]),ActorID);
 
                       ActiveCircuit[ActorID].Solution.LoadsNeedUpdating := TRUE;
                       FAvgpVuPrior[k] := FPresentVpu[k];
@@ -3113,6 +3112,7 @@ BEGIN
       if FVV_ReacPower_ref = 'VARAVAL_WATTS' then QHeadRoom[j] := SQRT(Sqr(PVSys.kVARating)-Sqr(PVSys.PresentkW));
       if (FVV_ReacPower_ref = 'VARMAX_VARS') or (FVV_ReacPower_ref = 'VARMAX_WATTS') then QHeadRoom[j] := PVSys.kvarLimit;
 
+      if(QHeadRoom[j] = 0) then QHeadRoom[j] := PVSys.kvarLimit;
       QPresentpu   := PVSys.Presentkvar / QHeadRoom[j];
       voltagechangesolution := 0.0;
 
diff --git a/Parallel_Version/Source/Controls/RegControl.pas b/Parallel_Version/Source/Controls/RegControl.pas
index 8a87f2f..8617a91 100644
--- a/Parallel_Version/Source/Controls/RegControl.pas
+++ b/Parallel_Version/Source/Controls/RegControl.pas
@@ -1228,7 +1228,7 @@ End;
 Procedure TRegControlObj.Reset;
 begin
       PendingTapChange := 0.0;
-
+      ARMED  := FALSE;
 end;
 
 procedure TRegcontrolObj.SaveWrite(var F: TextFile);
diff --git a/Parallel_Version/Source/DLL/ImplCapControls.pas b/Parallel_Version/Source/DLL/ImplCapControls.pas
index 9256324..5af9c4a 100644
--- a/Parallel_Version/Source/DLL/ImplCapControls.pas
+++ b/Parallel_Version/Source/DLL/ImplCapControls.pas
@@ -49,7 +49,8 @@ type
     procedure Set_Vmax(Value: Double); safecall;
     procedure Set_Vmin(Value: Double); safecall;
     function Get_Count: Integer; safecall;
-
+    procedure Reset; safecall;
+    
   end;
 
 implementation
@@ -402,6 +403,17 @@ begin
               Result := ActiveCircuit[ActiveActor].CapControls.ListSize ;
 end;
 
+procedure TCapControls.Reset;
+var
+  elem: TCapControlObj;
+begin
+  elem   := ActiveCapControl;
+  if elem <> nil then begin
+      elem.Reset;
+  end;
+
+end;
+
 initialization
   TAutoObjectFactory.Create(ComServer, TCapControls, Class_CapControls,
     ciInternal, tmApartment);
diff --git a/Parallel_Version/Source/DLL/ImplCircuit.pas b/Parallel_Version/Source/DLL/ImplCircuit.pas
index 2dc206b..828909c 100644
--- a/Parallel_Version/Source/DLL/ImplCircuit.pas
+++ b/Parallel_Version/Source/DLL/ImplCircuit.pas
@@ -726,7 +726,8 @@ Var
    iV               :LongWord;
    i,j,p            :LongWord;
    NValues          :LongWord;
-   hY, nBus, nNZ    :LongWord;
+   hY               :NativeUint;
+   nBus, nNZ        :LongWord;
    ColPtr, RowIdx   :array of LongWord;
    cVals            :array of Complex;
 
diff --git a/Parallel_Version/Source/DLL/ImplReclosers.pas b/Parallel_Version/Source/DLL/ImplReclosers.pas
index 401fbbf..9e76515 100644
--- a/Parallel_Version/Source/DLL/ImplReclosers.pas
+++ b/Parallel_Version/Source/DLL/ImplReclosers.pas
@@ -107,10 +107,10 @@ begin
         Repeat
           If pElem.Enabled Then Begin
               ActiveCircuit[ActiveActor].ActiveCktElement := pElem;
-              Result := 1;
+              Result := RecloserClass.ElementList.ActiveIndex;
           End
           Else pElem := RecloserClass.ElementList.Next;
-        Until (Result = 1) or (pElem = nil);
+        Until (Result >0) or (pElem = nil);
      End;
 end;
 
diff --git a/Parallel_Version/Source/DLL/ImplRegControls.pas b/Parallel_Version/Source/DLL/ImplRegControls.pas
index e91b7b9..1eb8be3 100644
--- a/Parallel_Version/Source/DLL/ImplRegControls.pas
+++ b/Parallel_Version/Source/DLL/ImplRegControls.pas
@@ -64,6 +64,7 @@ type
     procedure Set_TapNumber(Value: Integer); safecall;
 
     function Get_Count: Integer; safecall;
+    procedure Reset; safecall;
 
   end;
 
@@ -500,6 +501,17 @@ begin
      Result := ActiveCircuit[ActiveActor].RegControls.ListSize;
 end;
 
+procedure TRegControls.Reset;
+var
+  elem: TRegControlObj;
+begin
+  elem   := ActiveRegControl;
+  if elem <> nil then begin
+      elem.Reset;
+  end;
+
+end;
+
 initialization
   TAutoObjectFactory.Create(ComServer, TRegControls, Class_RegControls,
     ciInternal, tmApartment);
diff --git a/Parallel_Version/Source/DLL/ImplSolution.pas b/Parallel_Version/Source/DLL/ImplSolution.pas
index cc9c0bd..386f409 100644
--- a/Parallel_Version/Source/DLL/ImplSolution.pas
+++ b/Parallel_Version/Source/DLL/ImplSolution.pas
@@ -99,6 +99,8 @@ type
     function Get_Time_of_Step: Double; safecall;
     function Get_IntervalHrs: Double; safecall;
     procedure Set_IntervalHrs(Value: Double); safecall;
+    function Get_MinIterations: Integer; safecall;
+    procedure Set_MinIterations(Value: Integer); safecall;
     procedure SolveAll; safecall;
     function Get_IncMatrix: OleVariant; safecall;
     function Get_BusLevels: OleVariant; safecall;
@@ -230,7 +232,7 @@ procedure TSolution.Set_StepSize(Value: Double);
 begin
      If ActiveCircuit[ActiveActor] <> Nil Then Begin
          ActiveCircuit[ActiveActor].Solution.dynavars.h  := Value;
-         Set_IntervalHrs(Value);     // Keep IntervalHrs in synch with time step size
+         Set_IntervalHrs(Value/3600.0);     // Keep IntervalHrs in synch with time step size
      End;
 end;
 
@@ -702,6 +704,17 @@ begin
      If ActiveCircuit[ActiveActor] <> Nil Then ActiveCircuit[ActiveActor].Solution.IntervalHrs := Value;
 end;
 
+function TSolution.Get_MinIterations: Integer;
+begin
+     If ActiveCircuit <> Nil Then Result := ActiveCircuit[ActiveActor].Solution.MinIterations
+     Else Result := 0;
+end;
+
+procedure TSolution.Set_MinIterations(Value: Integer);
+begin
+    If ActiveCircuit <> Nil Then ActiveCircuit[ActiveActor].Solution.MinIterations  := Value;
+end;
+
 procedure TSolution.SolveAll;
 var
   i : Integer;
diff --git a/Parallel_Version/Source/DLL/OpenDSSengine.ridl b/Parallel_Version/Source/DLL/OpenDSSengine.ridl
index 27353f7..1cc1fa2 100644
--- a/Parallel_Version/Source/DLL/OpenDSSengine.ridl
+++ b/Parallel_Version/Source/DLL/OpenDSSengine.ridl
@@ -956,15 +956,23 @@ library OpenDSSengine
     HRESULT _stdcall Process_Time([out, retval] double* Value);
     [propget, id(0x000000E3), helpstring("Get the solution process time + sample time for time step")]
     HRESULT _stdcall Time_of_Step([out, retval] double* Value);
-    [id(0x000000E4), helpstring("Solves the circuits for all the Actors created")]
+    [propget, id(0x000000E4), helpstring("Get/Set the Solution.IntervalHrs variable used for devices that integrate")]
+    HRESULT _stdcall IntervalHrs([out, retval] double* Value);
+    [propput, id(0x000000E4), helpstring("Get/Set the Solution.IntervalHrs variable for custom solution algorithms")]
+    HRESULT _stdcall IntervalHrs([in] double Value);
+    [propget, id(0x000000E5), helpstring("Minimum number of iterations required for a power flow solution.")]
+    HRESULT _stdcall MinIterations([out, retval] long* Value);
+    [propput, id(0x000000E5), helpstring("Mininum number of iterations required for a power flow solution.")]
+    HRESULT _stdcall MinIterations([in] long Value);
+    [id(0x000000E6), helpstring("Solves the circuits for all the Actors created")]
     HRESULT _stdcall SolveAll(void);
-    [propget, id(0x000000E5)]
+    [propget, id(0x000000E7)]
     HRESULT _stdcall IncMatrix([out, retval] VARIANT* Value);
-    [propget, id(0x000000E6)]
+    [propget, id(0x000000E8)]
     HRESULT _stdcall IncMatrixRows([out, retval] VARIANT* Value);
-    [propget, id(0x000000E7)]
+    [propget, id(0x000000E9)]
     HRESULT _stdcall IncMatrixCols([out, retval] VARIANT* Value);
-    [propget, id(0x000000E8)]
+    [propget, id(0x000000E10)]
     HRESULT _stdcall BusLevels([out, retval] VARIANT* Value);
   };
 
@@ -1964,6 +1972,8 @@ library OpenDSSengine
     HRESULT _stdcall DeadTime([in] double Value);
     [propget, id(0x000000DB), helpstring("Number of CapControls in Active Circuit\0ep. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
     HRESULT _stdcall Count([out, retval] long* Value);
+    [id(0x000000DC), helpstring("Force a Reset of this CapControl")]
+    HRESULT _stdcall Reset(void);
   };
 
   [
@@ -2071,6 +2081,8 @@ library OpenDSSengine
     HRESULT _stdcall TapNumber([out, retval] long* Value);
     [propput, id(0x000000E2), helpstring("Integer number of the tap that the controlled transformer winding is currentliy on.")]
     HRESULT _stdcall TapNumber([in] long Value);
+    [id(0x000000E3), helpstring("Force Reset of this RegControl element")]
+    HRESULT _stdcall Reset(void);
   };
 
   [
diff --git a/Parallel_Version/Source/Executive/ExecOptions.pas b/Parallel_Version/Source/Executive/ExecOptions.pas
index d4da4ce..285b244 100644
--- a/Parallel_Version/Source/Executive/ExecOptions.pas
+++ b/Parallel_Version/Source/Executive/ExecOptions.pas
@@ -11,7 +11,7 @@ interface
 Uses Command;
 
 CONST
-        NumExecOptions = 118;
+        NumExecOptions = 120;
 
 VAR
          ExecOption,
@@ -142,16 +142,18 @@ Begin
      ExecOption[106] := 'ProcessTime';
      ExecOption[107] := 'TotalTime';
      ExecOption[108] := 'StepTime';
-     ExecOption[109] := 'NumCPUs';
-     ExecOption[110] := 'NumCores';
-     ExecOption[111] := 'NumActors';
-     ExecOption[112] := 'ActiveActor';
-     ExecOption[113] := 'CPU';
-     ExecOption[114] := 'ActorProgress';
-     ExecOption[115] := 'Parallel';
-     ExecOption[116] := 'ConcatenateReports';
-     ExecOption[117] := 'DSSVisualizationTool';
-     ExecOption[118] := 'DSSVInstalled';
+     ExecOption[109] := 'SampleEnergyMeters';
+     ExecOption[110] := 'MinIterations'; // default is 2
+     ExecOption[111] := 'NumCPUs';
+     ExecOption[112] := 'NumCores';
+     ExecOption[113] := 'NumActors';
+     ExecOption[114] := 'ActiveActor';
+     ExecOption[115] := 'CPU';
+     ExecOption[116] := 'ActorProgress';
+     ExecOption[117] := 'Parallel';
+     ExecOption[118] := 'ConcatenateReports';
+     ExecOption[119] := 'DSSVisualizationTool';
+     ExecOption[120] := 'DSSVInstalled';
 
 
 
@@ -174,7 +176,7 @@ Begin
                     CRLF+'  Yearly (follow Yearly curve),'+
                     CRLF+'  DIrect,'+
                     CRLF+'  DUtycycle,'+
-                    CRLF+'  Time, ( see LoadShapeClass option)' +
+                    CRLF+'  Time, ( see LoadShapeClass, SampleEnergymeters options)' +
                     CRLF+'  DYnamic,  ( see LoadShapeClass option)'+
                     CRLF+'  Harmonic,'+
                     CRLF+'  HarmonicT,  (sequential Harmonic Mode)'+
@@ -186,9 +188,7 @@ Begin
                     CRLF+'  Peakday,'+
                     CRLF+'  LD1 (load-duration 1)'+
                     CRLF+'  LD2 (load-duration 2)'+
-                    CRLF+'  AutoAdd (see AddType)' +
-                    CRLF+'  YearlyVQ (Yearly Vector Quantiaztion)' +
-                    CRLF+'  DutyVQ (Duty Vector Quantiaztion)' +CRLF +CRLF+
+                    CRLF+'  AutoAdd (see AddType)' +CRLF +CRLF+
                     'Side effect: setting the Mode propergy resets all monitors and energy meters. It also ' +
                     'resets the time step, etc. to defaults for each mode.  After the initial reset, the user ' +
                     'must explicitly reset the monitors and/or meters until another Set Mode= command.';
@@ -275,7 +275,7 @@ Begin
                         'Examples:'+Crlf+CRlf+
                         'Set autobuslist=(bus1, bus2, bus3, ... )' +CRLF+
                         'Set autobuslist=(file=buslist.txt)';
-     OptionHelp[43] := '{OFF | STATIC |EVENT | TIME}  Default is "STATIC".  Control mode for the solution. ' +
+     OptionHelp[43] := '{OFF | STATIC |EVENT | TIME | MULTIRATE}  Default is "STATIC".  Control mode for the solution. ' +
                         'Set to OFF to prevent controls from changing.' + CRLF +
                         'STATIC = Time does not advance.  Control actions are executed in order of shortest time to act ' +
                         'until all actions are cleared from the control queue.  Use this mode for power flow solutions which may require several ' +
@@ -284,6 +284,9 @@ Begin
                         'are executed and the time is advanced automatically to the time of the event. ' + crlf +crlf+
                         'TIME = solution is time driven.  Control actions are executed when the time for the pending ' +
                         'action is reached or surpassed.' + CRLF + CRLF +
+                        'MULTIRATE = solution is time driven.  Control actions are executed when the time for the pending ' +
+                        'action is reached or surpassed. In this control mode a solution is performed after each control action' +
+                        'is performed to reduce the error accumulated when the time step is to long' + CRLF + CRLF +
                         'Controls may reset and may choose not to act when it comes their time. ' +CRLF+
                         'Use TIME mode when modeling a control externally to the DSS and a solution mode such as ' +
                         'DAILY or DUTYCYCLE that advances time, or set the time (hour and sec) explicitly from the external program. ';
@@ -400,18 +403,22 @@ Begin
      OptionHelp[106] := 'The time in microseconds to execute the solve process in the most recent time step or solution (read only)';
      OptionHelp[107] := 'The accumulated time in microseconds to solve the circuit since the last reset. Set this value to reset the accumulator.';
      OptionHelp[108] := 'Process time + meter sampling time in microseconds for most recent time step - (read only)';
-     OptionHelp[109] := 'Delivers the number of threads (CPUs) available on the machine (read Only)';
-     OptionHelp[110] := 'Delivers the number of physical processors (Cores) available on the computer. If your computers processor has less than 64 cores, this number should be equal to the half of the available CPUs, otherise the number should  be the same (Read Only)';
-     OptionHelp[111] := 'Delivers the number of Actors created by the user, 1 is the default';
-     OptionHelp[112] := 'Gets/Sets the number of the active actor';
-     OptionHelp[113] := 'Gets/Sets the CPU to be used by the active actor';
-     OptionHelp[114] := 'Gets progress (%) for all the actors when performing a task';
-     OptionHelp[115] := 'Activates/Deactivates the parallel machine in OpenDSS-PM, if deactivated OpenDSS will behave as the classical version';
-     OptionHelp[116] := 'Activates/Deactivates the option for concatenate the reports generated by the existing actors, if Yes, everytime the user' +
+     OptionHelp[109] := '{YES/TRUE | NO/FALSE} Overrides default value for sampling EnergyMeter objects at the end of the solution loop. ' +
+                        'Normally Time and Duty modes do not automatically sample EnergyMeters whereas Daily, Yearly, M1, M2, M3, LD1 and LD2 modes do. ' +
+                        'Use this Option to turn sampling on or off';
+     OptionHelp[110] := 'Minimum number of iterations required for a solution. Default is 2.';
+     OptionHelp[111] := 'Delivers the number of threads (CPUs) available on the machine (read Only)';
+     OptionHelp[112] := 'Delivers the number of physical processors (Cores) available on the computer. If your computers processor has less than 64 cores, this number should be equal to the half of the available CPUs, otherise the number should  be the same (Read Only)';
+     OptionHelp[113] := 'Delivers the number of Actors created by the user, 1 is the default';
+     OptionHelp[114] := 'Gets/Sets the number of the active actor';
+     OptionHelp[115] := 'Gets/Sets the CPU to be used by the active actor';
+     OptionHelp[116] := 'Gets progress (%) for all the actors when performing a task';
+     OptionHelp[117] := 'Activates/Deactivates the parallel machine in OpenDSS-PM, if deactivated OpenDSS will behave as the classical version';
+     OptionHelp[118] := 'Activates/Deactivates the option for concatenate the reports generated by the existing actors, if Yes, everytime the user' +
                         'a show/export monitor command the report will include the data generated by all the actors, otherwise the report will contain' +
                         'The data generated by the active actor';
-     OptionHelp[117] := 'Activates/Deactivates the extended version of the plot command for figures with the DSS Visualization Tool.';
-     OptionHelp[118] := 'Returns Yes/No if the DSS Visualization Tool is installed (Read Only)';
+     OptionHelp[119] := 'Activates/Deactivates the extended version of the plot command for figures with the DSS Visualization Tool.';
+     OptionHelp[120] := 'Returns Yes/No if the DSS Visualization Tool is installed (Read Only)';
 End;
 //----------------------------------------------------------------------------
 FUNCTION DoSetCmd_NoCircuit:Boolean;  // Set Commands that do not require a circuit
@@ -443,27 +450,27 @@ Begin
            67: DSSExecutive.RecorderOn := InterpretYesNo(Param);
            73: DefaultBaseFreq  := Parser[ActiveActor].DblValue;
           102: UpdateRegistry   := InterpretYesNo(Param);
-          112:  Begin
+          114:  Begin
                   if Parser[ActiveActor].IntValue <= NumOfActors then ActiveActor  :=  Parser[ActiveActor].IntValue
                   else
                   begin
                     DoSimpleMsg('The actor does not exists',7002);
                   end;
                 End;
-          113:  Begin
+          115:  Begin
                   if Parser[ActiveActor].IntValue < CPU_Cores then ActorCPU[ActiveActor]  :=  Parser[ActiveActor].IntValue
                   else
                   begin
                     DoSimpleMsg('The CPU does not exists',7003);
                   end;
                 End;
-          115:  begin
+          117:  begin
                   Parallel_enabled  :=  InterpretYesNo(Param);
                 end;
-          116:  begin
+          118:  begin
                   ConcatenateReports  :=  InterpretYesNo(Param);
                 end;
-          117:  begin
+          119:  begin
                   DSS_Viz_enable  :=  InterpretYesNo(Param);
                 end;
          ELSE
@@ -656,27 +663,29 @@ Begin
           104: ActiveCircuit[ActiveActor].RelayMarkerCode  := Parser[ActiveActor].IntValue;
           105: ActiveCircuit[ActiveActor].RelayMarkerSize  := Parser[ActiveActor].IntValue;
           107: ActiveCircuit[ActiveActor].Solution.Total_Time  :=  Parser[ActiveActor].DblValue;
-          112:  Begin
+          109: ActiveCircuit[ActiveActor].Solution.SampleTheMeters :=  InterpretYesNo(Param);
+          110: ActiveCircuit[ActiveActor].solution.MinIterations   := Parser[ActiveActor].IntValue;
+          114:  Begin
                   if Parser[ActiveActor].IntValue <= NumOfActors then ActiveActor  :=  Parser[ActiveActor].IntValue
                   else
                   begin
                     DoSimpleMsg('The actor does not exists',7002);
                   end;
                 End;
-          113:  Begin
+          115:  Begin
                   if Parser[ActiveActor].IntValue < CPU_Cores then ActorCPU[ActiveActor]  :=  Parser[ActiveActor].IntValue
                   else
                   begin
                     DoSimpleMsg('The CPU does not exists',7003);
                   end;
                 End;
-          115:  begin
+          117:  begin
                   Parallel_enabled  :=  InterpretYesNo(Param);
                 end;
-          116:  begin
+          118:  begin
                   ConcatenateReports  :=  InterpretYesNo(Param);
                 end;
-          117:  begin
+          119:  begin
                   DSS_Viz_enable  :=  InterpretYesNo(Param);
                 end;
          ELSE
@@ -685,6 +694,8 @@ Begin
 
          CASE ParamPointer OF
               3,4: ActiveCircuit[ActiveActor].Solution.Update_dblHour;
+              // Update IntervalHrs for devices that integrate
+              7,18: ActiveCircuit[ActiveActor].Solution.IntervalHrs := ActiveCircuit[ActiveActor].Solution.DynaVars.h / 3600.0;
          END;
 
          ParamName := Parser[ActiveActor].NextParam;
@@ -706,7 +717,7 @@ VAR
    ParamPointer, i:Integer;
    ParamName:String;
    Param:String;
-   ScriptEd : TScriptEdit;
+   {$IFNDEF FPC}ScriptEd : TScriptEdit;{$ENDIF}
 
 Begin
 
@@ -846,27 +857,29 @@ Begin
            99: If ActiveCircuit[ActiveActor].MarkReclosers Then AppendGlobalResult('Yes') else AppendGlobalResult('No');
           100: AppendGlobalResult(Format('%d' ,[ActiveCircuit[ActiveActor].RecloserMarkerCode]));
           101: AppendGlobalResult(Format('%d' ,[ActiveCircuit[ActiveActor].RecloserMarkerSize]));
-          102: UpdateRegistry                    := InterpretYesNo(Param);
+          102: If UpdateRegistry Then AppendGlobalResult('Yes') else AppendGlobalResult('No');
           103: If ActiveCircuit[ActiveActor].MarkRelays Then AppendGlobalResult('Yes') else AppendGlobalResult('No');
           104: AppendGlobalResult(Format('%d' ,[ActiveCircuit[ActiveActor].RelayMarkerCode]));
           105: AppendGlobalResult(Format('%d' ,[ActiveCircuit[ActiveActor].RelayMarkerSize]));
           106: AppendGlobalResult(Format('%-g' ,[ActiveCircuit[ActiveActor].Solution.Time_Solve]));
           107: AppendGlobalResult(Format('%-g' ,[ActiveCircuit[ActiveActor].Solution.Total_Time]));
           108: AppendGlobalResult(Format('%-g' ,[ActiveCircuit[ActiveActor].Solution.Time_Step]));
-          109: AppendGlobalResult(Format('%d' ,[CPU_Cores]));
-          110:
+          109: If ActiveCircuit[ActiveActor].Solution.SampleTheMeters Then AppendGlobalResult('Yes') else AppendGlobalResult('No');
+          110: AppendGlobalResult(IntToStr(ActiveCircuit[ActiveActor].solution.MinIterations));
+          111: AppendGlobalResult(Format('%d' ,[CPU_Cores]));
+          112:
             begin
               if CPU_Cores < 64 then AppendGlobalResult(Format('%-g' ,[CPU_Cores/2]))
               else AppendGlobalResult(Format('%d' ,[CPU_Cores]));
             end;
-          111: AppendGlobalResult(Format('%d' ,[NumOfActors]));
-          112: AppendGlobalResult(Format('%d' ,[ActiveActor]));
-          113: AppendGlobalResult(Format('%d' ,[ActorCPU[ActiveActor]]));
-          114: ScriptEd.UpdateProgressSummary;
-          115: if parallel_enabled then AppendGlobalResult('Yes') else AppendGlobalResult('No');
-          116: if ConcatenateReports then AppendGlobalResult('Yes') else AppendGlobalResult('No');
-          117: if DSS_Viz_enable then AppendGlobalResult('Yes') else AppendGlobalResult('No');
-          118: if DSS_Viz_installed then AppendGlobalResult('Yes') else AppendGlobalResult('No');
+          113: AppendGlobalResult(Format('%d' ,[NumOfActors]));
+          114: AppendGlobalResult(Format('%d' ,[ActiveActor]));
+          115: AppendGlobalResult(Format('%d' ,[ActorCPU[ActiveActor]]));
+          116: {$IFNDEF FPC}ScriptEd.UpdateProgressSummary;{$ELSE} ; {$ENDIF}
+          117: if parallel_enabled then AppendGlobalResult('Yes') else AppendGlobalResult('No');
+          118: if ConcatenateReports then AppendGlobalResult('Yes') else AppendGlobalResult('No');
+          119: if DSS_Viz_enable then AppendGlobalResult('Yes') else AppendGlobalResult('No');
+          120: if DSS_Viz_installed then AppendGlobalResult('Yes') else AppendGlobalResult('No');
 
          ELSE
            // Ignore excess parameters
diff --git a/Parallel_Version/Source/Executive/ExportOptions.pas b/Parallel_Version/Source/Executive/ExportOptions.pas
index 9166cb6..ba0a008 100644
--- a/Parallel_Version/Source/Executive/ExportOptions.pas
+++ b/Parallel_Version/Source/Executive/ExportOptions.pas
@@ -105,7 +105,7 @@ Begin
                         ' cause a separate file to be written for each meter.';
       ExportHelp[15] := '(file name is assigned by Monitor export) Monitor values.';
       ExportHelp[16] := '(Default file = EXP_YPRIMS.CSV) All primitive Y matrices.';
-      ExportHelp[17] := '(Default file = EXP_Y.CSV) System Y matrix.';
+      ExportHelp[17] := '(Default file = EXP_Y.CSV) [triplets] [Filename] System Y matrix, defaults to non-sparse format.';
       ExportHelp[18] := '(Default file = EXP_SEQZ.CSV) Equivalent sequence Z1, Z0 to each bus.';
       ExportHelp[19] := '(Default file = EXP_P_BYPHASE.CSV) [MVA] [Filename] Power by phase. Default is kVA.';
       ExportHelp[20] := '(Default file = CIM17x.XML) (IEC 61968-13, CIM v17 extended, CDPSM Combined (unbalanced load flow) profile)' + CRLF
@@ -165,7 +165,7 @@ VAR
 
    MVAopt               :Integer;
    UEonlyOpt            :Boolean;
-   TripletOpt   :Boolean;
+   TripletOpt           :Boolean;
    pMon                 :TMonitorObj;
    pMeter               :TEnergyMeterObj;
    ParamPointer         :Integer;
@@ -177,6 +177,7 @@ VAR
 Begin
    Result := 0;
    AbortExport := FALSE;
+   FileName := '';
 
    ParamName := Parser[ActiveActor].NextParam;
    Parm1 := LowerCase(Parser[ActiveActor].StrValue);
@@ -388,7 +389,7 @@ Begin
          End
          ELSE   DoSimpleMsg('Monitor Name Not Specified.'+ CRLF + parser[ActiveActor].CmdString, 251);
      16: ExportYprim(Filename);
-     17: ExportY(Filename);
+     17: ExportY(Filename, TripletOpt);
      18: ExportSeqZ(Filename);
      19: ExportPbyphase(Filename, MVAOpt);
      20: ExportCDPSM (Filename, Substation, SubGeographicRegion, GeographicRegion, Combined);
diff --git a/Parallel_Version/Source/General/LoadShape.pas b/Parallel_Version/Source/General/LoadShape.pas
index 939b75d..7da39b4 100644
--- a/Parallel_Version/Source/General/LoadShape.pas
+++ b/Parallel_Version/Source/General/LoadShape.pas
@@ -703,8 +703,6 @@ Function TLoadShapeObj.GetMult(hr:double):Complex;
 
 VAR
    Index, i : Integer;
-   R_part,
-   Im_part  : Double;
 
    Function Set_Result_im(const realpart:double):Double;
    {Set imaginary part of Result when Qmultipliers not defined}
@@ -730,11 +728,9 @@ BEGIN
            Index := round(hr/Interval);
            IF Index>FNumPoints Then Index := Index Mod FNumPoints;  // Wrap around using remainder
            IF Index=0 THEN Index := FNumPoints;
-           R_part     :=  PMultipliers^[Index];
+           Result.Re := PMultipliers^[Index];
            If Assigned(QMultipliers) Then Result.im := QMultipliers^[Index]
-           Else  Im_part  := Set_Result_im(R_part);
-           Result.re      :=  R_part;
-           Result.im      :=  Im_part;
+           Else  Result.im := Set_Result_im(Result.re);
         END
       ELSE  BEGIN
           // For random interval
diff --git a/Parallel_Version/Source/Meters/Monitor.pas b/Parallel_Version/Source/Meters/Monitor.pas
index 5f084b1..7407f4c 100644
--- a/Parallel_Version/Source/Meters/Monitor.pas
+++ b/Parallel_Version/Source/Meters/Monitor.pas
@@ -1616,7 +1616,7 @@ begin
 
            {Now find Maxtime in Monitor}
            PositionSave := MonitorStream.Position;
-           MonitorStream.Seek(-(Recordbytes+8), soFromEnd);
+           MonitorStream.Seek(-(Recordbytes+8), soEnd);
            If Not (MonitorStream.Position>=MonitorStream.Size) Then
              With MonitorStream Do Begin
                   Read( hr, 4);  // singles
@@ -1632,7 +1632,7 @@ begin
            END;
 
            {Go Back to where we were}
-           MonitorStream.Seek(PositionSave, soFromBeginning);
+           MonitorStream.Seek(PositionSave, soBeginning);
 
            TopTransferFile.WriteHeader(Time, MaxTime, Time, RecordSize, 0, 16,  'DSS (TM), EPRI (R)');
            TopTransferFile.WriteNames(NameList, CNames);
diff --git a/Parallel_Version/Source/PCElements/PVsystem.pas b/Parallel_Version/Source/PCElements/PVsystem.pas
index 1ca39a3..103179f 100644
--- a/Parallel_Version/Source/PCElements/PVsystem.pas
+++ b/Parallel_Version/Source/PCElements/PVsystem.pas
@@ -1297,7 +1297,7 @@ Begin
               CASE Mode OF
                   SNAPSHOT:    ; {Just solve for the present kW, kvar}  // Don't check for state change
                   DAILYMODE:  Begin  CalcDailyMult(DynaVars.dblHour);  CalcDailyTemperature(DynaVars.dblHour); End;
-                  YEARLYMODE,DUTYCYCLE: Begin  CalcYearlyMult(DynaVars.dblHour); CalcYearlyTemperature(DynaVars.dblHour); End;
+                  YEARLYMODE: Begin  CalcYearlyMult(DynaVars.dblHour); CalcYearlyTemperature(DynaVars.dblHour); End;
                (*
                   MONTECARLO1,
                   MONTEFAULT,
@@ -1322,7 +1322,7 @@ Begin
                   LOADDURATION2: Begin CalcDailyMult(DynaVars.dblHour); CalcDailyTemperature(DynaVars.dblHour); End;
                   PEAKDAY:       Begin CalcDailyMult(DynaVars.dblHour); CalcDailyTemperature(DynaVars.dblHour); End;
 
-//                DUTYCYCLE:     Begin CalcDutyMult(DynaVars.dblHour) ; CalcDutyTemperature(DynaVars.dblHour) ;  End;
+                  DUTYCYCLE:     Begin CalcDutyMult(DynaVars.dblHour) ; CalcDutyTemperature(DynaVars.dblHour) ;  End;
                   {AUTOADDFLAG:  ; }
               END;
 
diff --git a/Parallel_Version/Source/PCElements/Storage.pas b/Parallel_Version/Source/PCElements/Storage.pas
index 78eb94f..e823474 100644
--- a/Parallel_Version/Source/PCElements/Storage.pas
+++ b/Parallel_Version/Source/PCElements/Storage.pas
@@ -2264,7 +2264,8 @@ begin
      CASE StorageState of
           STORE_CHARGING:   Result := abs(Power[1,ActiveActor].re * (100.0 - pctChargeEff)/100000.0) + pctChargeEff*kWIdlingLosses/100.0; // kW
           STORE_IDLING:     Result := kWIdlingLosses;
-          STORE_DISCHARGING:Result := abs(Power[1,ActiveActor].re * (100.0 - pctDisChargeEff)/100000.0) + (2.0 - pctChargeEff/100.0) * kWIdlingLosses;  // kW
+        //****  STORE_DISCHARGING:Result := abs(Power[1,ActiveActor].re * (100.0 - pctDisChargeEff)/100000.0) + (2.0 - pctChargeEff/100.0) * kWIdlingLosses;  // kW
+          STORE_DISCHARGING:Result := abs(Power[1,ActiveActor].re * (100.0 / pctDisChargeEff - 1.0)/1000.0) + (100.0/pctDisChargeEff) * kWIdlingLosses;  // kW
      END;
 end;
 
diff --git a/Parallel_Version/Source/PCElements/vccs.pas b/Parallel_Version/Source/PCElements/vccs.pas
index c55e998..683dad9 100644
--- a/Parallel_Version/Source/PCElements/vccs.pas
+++ b/Parallel_Version/Source/PCElements/vccs.pas
@@ -40,8 +40,11 @@ TYPE
         FsampleFreq: double; // discretization frequency for Z filter
         Fwinlen: integer;
         Ffiltlen: integer;
+        Irated: double; // line current at full output
+        Fkv: double; // scale voltage to HW pu input
+        Fki: double; // scale HW pu output to current
 
-        // Support for Dynamics Mode
+        // Support for Dynamics Mode - PU of Vrated and BaseCurr
         sVwave: double;
         sIwave: double;
         sIrms: double;
@@ -294,6 +297,8 @@ Begin
   Vrated := 208.0;
   Ppct := 100.0;
   FsampleFreq := 5000.0;
+  Fkv := 1.0;
+  Fki := 1.0;
 
   Fwinlen := 0;
   Ffilter_name := '';
@@ -328,7 +333,13 @@ Begin
     DoSimpleMsg('Spectrum Object "' + Spectrum + '" for Device VCCS.'+Name+' Not Found.', 333);
   end;
   Reallocmem(InjCurrent, SizeOf(InjCurrent^[1])*Yorder);
-  BaseCurr := 0.01 * Ppct * Prated / Vrated / FNphases;
+
+  Irated := Prated / Vrated / FNphases;
+  if FNPhases = 3 then Irated := Irated * sqrt(3);
+  BaseCurr := 0.01 * Ppct * Irated;
+  Fkv := 1.0 / Vrated / sqrt(2.0);
+  Fki := BaseCurr * sqrt(2.0);
+
   if Length (Ffilter_name) > 0 then begin
     Ffiltlen := Ffilter.NumPoints;
     Fwinlen := Trunc (FsampleFreq / BaseFrequency);
@@ -338,8 +349,6 @@ Begin
     Reallocmem (wlast, sizeof(wlast^[1]) * Ffiltlen);
     Reallocmem (zlast, sizeof(zlast^[1]) * Ffiltlen);
   end;
-
-  if FNPhases = 3 then BaseCurr := BaseCurr * sqrt(3);
 End;
 
 Procedure TVCCSObj.CalcYPrim(ActorID : Integer);
@@ -393,7 +402,7 @@ Begin
 //  IterminalUpdated := FALSE;
   if ActiveSolutionObj.IsDynamicModel then begin
     For i := 1 to Fnphases Do Begin
-      Curr^[i] := pdegtocomplex (sIrms, cdang(Vterminal^[i]));
+      Curr^[i] := pdegtocomplex (sIrms * BaseCurr, cdang(Vterminal^[i]));
     End;
   end else begin
     For i := 1 to Fnphases Do Begin
@@ -445,21 +454,20 @@ end;
 //     However, OpenDSS uses the load convention
 procedure TVCCSObj.InitStateVars(ActorID : Integer);
 var
-  d, wt, wd, val, iang, vang, pk: double;
+  d, wt, wd, val, iang, vang: double;
   i, k: integer;
 begin
   // initialize outputs from the terminal conditions
   ComputeIterminal(ActorID);
   iang := cang(Iterminal^[1]);
   vang := cang(Vterminal^[1]);
-  pk := sqrt(2);
-  sVwave := cabs(Vterminal^[1]) * pk;
-  sIrms := cabs(Iterminal^[1]);
-  sIwave := sIrms * pk;
-  sIpeak := sIrms * pk;
+  sVwave := cabs(Vterminal^[1]) / Vrated;
+  sIrms := cabs(Iterminal^[1]) / BaseCurr;
+  sIwave := sIrms;
+  sIpeak := sIrms;
   sBP1out := 0;
   sFilterout := 0;
-  vlast := Vterminal^[1];
+  vlast := cdivreal (Vterminal^[1], Vrated);
 
   // initialize the history terms for HW model source convention
   d := 1 / FsampleFreq;
@@ -472,7 +480,7 @@ begin
   end;
   for i := 1 to Fwinlen do begin
     wt := iang - wd * (Fwinlen - i);
-    val := pk * sIrms * cos(wt);  // current by passive sign convention
+    val := sIrms * cos(wt);  // current by passive sign convention
     y2[i] := val * val;
     k := i - Fwinlen + Ffiltlen;
     if k > 0 then begin
@@ -489,7 +497,7 @@ end;
 // this is called twice per dynamic time step; predictor then corrector
 procedure TVCCSObj.IntegrateStates(ActorID : Integer);
 var
-  t, h, d, f, w, wt, pk: double;
+  t, h, d, f, w, wt: double;
   vre, vim, vin, scale, y: double;
   nstep, i, k, corrector: integer;
   vnow: complex;
@@ -504,9 +512,8 @@ begin
   d := 1 / FSampleFreq;
   nstep := trunc (1e-6 + h/d);
   w := 2 * Pi * f;
-  pk := sqrt(2);
-
-  vnow := Vterminal^[1];
+  
+  vnow := cdivreal (Vterminal^[1], Vrated);
   vin := 0;
   y := 0;
   iu := sIdxU;
@@ -522,7 +529,7 @@ begin
     vre := vlast.re + (vnow.re - vlast.re) * scale;
     vim := vlast.im + (vnow.im - vlast.im) * scale;
     wt := w * (t - h + i * d);
-    vin := pk * (vre * cos(wt) + vim * sin(wt));
+    vin := (vre * cos(wt) + vim * sin(wt));
     whist[iu] := Fbp1.GetYValue(vin);
     // apply the filter and second PWL block
     z[iu] := 0;
@@ -542,7 +549,7 @@ begin
     if i = nstep then begin
       y2sum := 0.0;
       for k := 1 to Fwinlen do y2sum := y2sum + y2[k];
-      sIrms := sqrt(y2sum / Fwinlen); // TODO - this is the magnitude, what about angle?
+      sIrms := sqrt(2.0 * y2sum / Fwinlen); // TODO - this is the magnitude, what about angle?
     end;
   end;
 
diff --git a/Parallel_Version/Source/PDElements/Line.pas b/Parallel_Version/Source/PDElements/Line.pas
index 5d2bff3..6410000 100644
--- a/Parallel_Version/Source/PDElements/Line.pas
+++ b/Parallel_Version/Source/PDElements/Line.pas
@@ -70,6 +70,8 @@ TYPE
 
         Procedure ReallocZandYcMatrices;
 
+        PROCEDURE DoLongLine(Frequency:Double);  // Long Line Correction for 1=phase
+
       Protected
         Zinv               :TCMatrix;
 
@@ -807,6 +809,36 @@ begin
     Yc   := TCMatrix.CreateMatrix(Fnphases);
 end;
 
+PROCEDURE TLineObj.DoLongLine(Frequency:Double);
+// do long line correction for len and frequwnen
+
+Var
+   Zs, Zm, Ys, Ym : Complex;
+   GammaL, ExpP, ExpM, Exp2P, Exp2M, SinhGL, Tanh2GL : Complex;
+
+Begin
+
+ // nominal PI parameters per unit length but Len variable is used here
+        Zs := cmplx (R1, X1);
+        Ys := cmplx (0.0, TwoPi * Frequency * C1);
+        // apply the long-line correction to obtain Zm and Ym
+        GammaL  := Csqrt (Cmul(Zs, Ys));
+        GammaL  := CmulReal (GammaL, Len);
+        ExpP    := CmulReal (cmplx(cos(GammaL.im), sin(GammaL.im)), exp(GammaL.re));
+        Exp2P   := CmulReal (cmplx(cos(0.5 * GammaL.im), sin(0.5 * GammaL.im)), exp(0.5 * GammaL.re));
+        ExpM    := Cinv(ExpP);
+        Exp2M   := Cinv(Exp2P);
+        SinhGL  := CmulReal (Csub (ExpP, ExpM), 0.5);
+        Tanh2GL := Cdiv (Csub (Exp2P, Exp2M), Cadd (Exp2P, Exp2M));
+        Zm := Cdiv (Cmul (CMulReal (Zs, Len), SinhGL), GammaL);
+        Ym := Cdiv (Cmul (CMulReal (Ys, Len), Tanh2GL), CmulReal (GammaL, 0.5));
+        // rely on this function being called only once, unless R1, X1, or C1 changes
+        R1 := Zm.re / Len;
+        X1 := Zm.im / Len;
+        C1 := Ym.im / Len / TwoPi / Frequency;
+
+End;
+
 PROCEDURE TLineObj.RecalcElementData(ActorID : Integer);
 
 {
@@ -819,7 +851,6 @@ VAR
    Zs, Zm, Ys, Ym, Ztemp : Complex;
    i, j : Integer;
    Yc1, Yc0, OneThird : double;
-   GammaL, ExpP, ExpM, Exp2P, Exp2M, SinhGL, Tanh2GL : Complex;
 
 Begin
 
@@ -836,24 +867,7 @@ Begin
       // long-line equivalent PI, but only for CktModel=Positive
       if ActiveCircuit[ActorID].PositiveSequence and (C1 > 0) then
       begin
-        // nominal PI parameters per unit length but Len variable is used here
-        Zs := cmplx (R1, X1);
-        Ys := cmplx (0.0, TwoPi * BaseFrequency * C1);
-        // apply the long-line correction to obtain Zm and Ym
-        GammaL  := Csqrt (Cmul(Zs, Ys));
-        GammaL  := CmulReal (GammaL, Len);
-        ExpP    := CmulReal (cmplx(cos(GammaL.im), sin(GammaL.im)), exp(GammaL.re));
-        Exp2P   := CmulReal (cmplx(cos(0.5 * GammaL.im), sin(0.5 * GammaL.im)), exp(0.5 * GammaL.re));
-        ExpM    := Cinv(ExpP);
-        Exp2M   := Cinv(Exp2P);
-        SinhGL  := CmulReal (Csub (ExpP, ExpM), 0.5);
-        Tanh2GL := Cdiv (Csub (Exp2P, Exp2M), Cadd (Exp2P, Exp2M));
-        Zm := Cdiv (Cmul (CMulReal (Zs, Len), SinhGL), GammaL);
-        Ym := Cdiv (Cmul (CMulReal (Ys, Len), Tanh2GL), CmulReal (GammaL, 0.5));
-        // rely on this function being called only once, unless R1, X1, or C1 changes
-        R1 := Zm.re / Len;
-        X1 := Zm.im / Len;
-        C1 := Ym.im / Len / TwoPi / BaseFrequency;
+        DoLongLine(BaseFrequency);  // computes R1, X1, C1  per unit length
       end;
       // zero sequence the same as positive sequence
       R0 := R1;
diff --git a/Parallel_Version/Source/PDElements/Transformer.pas b/Parallel_Version/Source/PDElements/Transformer.pas
index 9415250..5e247ad 100644
--- a/Parallel_Version/Source/PDElements/Transformer.pas
+++ b/Parallel_Version/Source/PDElements/Transformer.pas
@@ -41,6 +41,7 @@ TYPE
        PROCEDURE InterpretAllkVRatings(const S:String);
        PROCEDURE InterpretAllkVARatings(const S:String);
        PROCEDURE InterpretAllRs(const S:String);
+        FUNCTION InterpretLeadLag(const S:String):Boolean;
        FUNCTION  TrapZero(const Value:Double; DefaultValue:Double):Double;
 
        {PROCEDURE MakeNewBusNameForNeutral(Var NewBusName:String; Nphases:Integer);}
@@ -144,6 +145,8 @@ TYPE
         pctLoadLoss       :Double;
         pctNoLoadLoss     :Double;
 
+        HVLeadsLV         :Boolean;
+
         XHLChanged        :Boolean;
 
         PROCEDURE SetTermRef;
@@ -225,7 +228,7 @@ USES    DSSClassDefs, DSSGlobals, Sysutils, Utilities, XfmrCode;
 var
    XfmrCodeClass:TXfmrCode;
 
-Const NumPropsThisClass = 43;
+Const NumPropsThisClass = 44;
 
 //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 constructor TTransf.Create;  // Creates superstructure for all Transformer objects
@@ -311,6 +314,7 @@ Begin
      PropertyName[41] := 'X12';
      PropertyName[42] := 'X13';
      PropertyName[43] := 'X23';
+     PropertyName[44] := 'LeadLag';                              
 
      // define Property help values
      PropertyHelp[1] := 'Number of phases this transformer. Default is 3.';
@@ -331,7 +335,9 @@ Begin
      PropertyHelp[8] := 'Per unit tap that this winding is on.';
      PropertyHelp[9] := 'Percent resistance this winding.  (half of total for a 2-winding).';
      PropertyHelp[10] := 'Default = -1. Neutral resistance of wye (star)-connected winding in actual ohms.' +
-                         'If entered as a negative value, the neutral is assumed to be open, or floating.';
+                         'If entered as a negative value, the neutral is assumed to be open, or floating. ' +
+                         'To solidly ground the neutral, connect the neutral conductor to Node 0 in the Bus property spec for this winding. ' +
+                         'For example: Bus=MyBusName.1.2.3.0, which is generally the default connection.';
      PropertyHelp[11] := 'Neutral reactance of wye(star)-connected winding in actual ohms.  May be + or -.';
 
    // General Data
@@ -390,6 +396,9 @@ Begin
                          'for 3-winding transformers only. Percent on the kVA base of winding 1. ';
      PropertyHelp[43] := 'Alternative to XLT for specifying the percent reactance from winding 2 to winding 3.Use '+
                          'for 3-winding transformers only. Percent on the kVA base of winding 1.  ';
+     PropertyHelp[44] := '{Lead | Lag (default) | ANSI (default) | Euro } Designation in mixed Delta-wye connections the '+
+                         'relationship between HV to LV winding. Default is ANSI 30 deg lag, e.g., Dy1 of Yd1 vector group. ' +
+                         'To get typical European Dy11 connection, specify either "lead" or "Euro"';
 
      ActiveProperty := NumPropsThisClass;
      inherited DefineProperties;  // Add defs of inherited properties to bottom of list
@@ -486,6 +495,7 @@ Begin
            41: XHL :=  TrapZero(parser[ActorID].Dblvalue, 7.0) * 0.01;
            42: XHT :=  TrapZero(parser[ActorID].Dblvalue, 35.0) * 0.01;
            43: XLT :=  TrapZero(parser[ActorID].Dblvalue, 30.0) * 0.01;
+           44: HVLeadsLV := InterpretLeadLag(Param);
          ELSE
            // Inherited properties
               ClassEdit(ActiveTransfObj, ParamPointer - NumPropsThisClass)
@@ -631,6 +641,22 @@ End;
 
 
 //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+FUNCTION TTransf.InterpretLeadLag(const S:String):Boolean;
+//  routine expecting all winding bus connections expressed in one array of strings
+VAR
+    BusNam  :String;
+    i       :Integer;
+Begin
+
+    Result := FALSE;   // default to ANSI 30 Deg Lag if can't understand S
+
+    if CompareTextShortest(S, 'lead')=0       then Result := TRUE
+    Else if CompareTextShortest(S, 'euro')=0  then   Result := TRUE;
+
+End;
+
+
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 PROCEDURE TTransf.InterpretAllkVRatings(const S:String);
 //  routine expecting all winding kV ratings expressed in one array of strings
 VAR
@@ -853,6 +879,8 @@ Begin
   IsSubstation  := FALSE;
   XRConst       := FALSE;
 
+  HVLeadsLV     := FALSE; // Defaults to ANSI connection
+
   Y_Terminal_FreqMult := 0.0;
 
   Yorder := fNTerms * fNconds;
@@ -933,8 +961,8 @@ Begin
    Else Begin
      If Winding^[1].kvll >= Winding^[2].kvll Then iHvolt:=1 else iHVolt := 2;
      CASE Winding^[iHvolt].Connection of
-       0:  DeltaDirection := 1;
-       1:  DeltaDirection := -1;
+       0:  If HVLeadsLV then DeltaDirection := -1 Else DeltaDirection := 1;
+       1:  If HVLeadsLV then DeltaDirection := 1  Else DeltaDirection := -1;
      ELSE
          // ---old code --- If Winding^[2].Connection = 0 Then DeltaDirection := -1 Else DeltaDirection := 1;
      END;
@@ -1586,6 +1614,7 @@ begin
      PropertyValue[41] := '7';   // Same as XHT ...
      PropertyValue[42] := '35';
      PropertyValue[43] := '30';
+     PropertyValue[44] := 'Lag';
 
 
   inherited  InitPropertyValues(NumPropsThisClass);
-- 
2.10.0.windows.1

